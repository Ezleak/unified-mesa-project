diff --git a/.github/workflows/android.yml b/.github/workflows/android.yml
new file mode 100644
index 0000000..d05a936
--- /dev/null
+++ b/.github/workflows/android.yml
@@ -0,0 +1,65 @@
+
+name: Build Android
+
+on:
+  [push, pull_request]
+
+# A workflow run is made up of one or more jobs that can run sequentially or in parallel
+jobs:
+  build:
+    strategy:
+      matrix:
+        arch: [ "arm32", "aarch64", "x86_64" ]
+      fail-fast: false
+
+    name: "Build for ${{matrix.arch}}"
+
+    runs-on: ubuntu-20.04
+
+    steps:
+      - uses: actions/checkout@v2
+
+      - name: Build
+        run: |
+          ln -s vulkan_android.pc vulkan.pc
+          sudo apt update
+          sudo apt install -y meson libxrandr-dev libxxf86vm-dev libxcb-*-dev libx11-xcb-dev libxfixes-dev libdrm-dev libx11-dev
+          cp -R /usr/include/X11 include/
+          cp -R /usr/include/xcb include/
+          cp -R /usr/include/GL/* include/GL/
+          pip3 install mako
+          export ANDROID_NDK_HOME="$ANDROID_SDK_ROOT/ndk-bundle"
+          # -Dglx=gallium-xlib \
+          meson "build-android-${{matrix.arch}}" \
+            --prefix=/tmp/zink \
+            --cross-file "android-${{matrix.arch}}" \
+            --buildtype debug \
+            -Dplatforms=android \
+            -Dplatform-sdk-version=24 \
+            -Dandroid-stub=true \
+            -Dllvm=disabled \
+            -Dxlib-lease=disabled \
+            -Degl=disabled \
+            -Dgbm=disabled \
+            -Dglx=dri \
+            -Dglx-direct=true \
+            -Dopengl=true \
+            -Dosmesa=true \
+            -Dvulkan-drivers= \
+            -Dgallium-drivers=virgl \
+            -Dshared-glapi=false
+          ninja -C "build-android-${{matrix.arch}}" install
+          # cp "build-android-${{matrix.arch}}/src/gallium/drivers/zink/libzink.a" /tmp/zink/lib/
+          rm /tmp/zink/lib/libOSMesa.so /tmp/zink/lib/libOSMesa.so.8
+          mv /tmp/zink/lib/libOSMesa.so.8.0.0 /tmp/zink/lib/libOSMesa.so.8
+          cp /tmp/zink/lib/libOSMesa.so.8 /tmp/zink/lib/libOSMesa_unstripped.so.8
+          if [ "${{matrix.arch}}" == "arm32" ]; then
+            /usr/local/lib/android/sdk/ndk-bundle/toolchains/llvm/prebuilt/linux-x86_64/bin/arm-linux-androideabi-strip /tmp/zink/lib/libOSMesa.so.8
+          else
+            /usr/local/lib/android/sdk/ndk-bundle/toolchains/llvm/prebuilt/linux-x86_64/bin/${{matrix.arch}}-linux-android-strip /tmp/zink/lib/libOSMesa.so.8
+          fi
+      - name: Upload libraries
+        uses: actions/upload-artifact@v2
+        with:
+          name: libzink_${{matrix.arch}}
+          path: /tmp/zink
diff --git a/.github/workflows/ios.yml b/.github/workflows/ios.yml
new file mode 100644
index 0000000..e7c531c
--- /dev/null
+++ b/.github/workflows/ios.yml
@@ -0,0 +1,48 @@
+
+name: Build iOS
+
+on:
+  [push, pull_request]
+
+jobs:
+  build:
+    runs-on: macos-latest
+
+    steps:
+      - uses: actions/checkout@v2
+
+      - name: Build iOS
+        run: |
+          git clone --depth 1 https://github.com/KhronosGroup/MoltenVK
+          ln -s vulkan_ios.pc vulkan.pc
+          brew install meson pkg-config
+          # sudo apt install -y meson libxrandr-dev libxxf86vm-dev libxshmfence-dev libxcb-*-dev libx11-xcb-dev libxfixes-dev libdrm-dev libx11-dev
+          # cp -R /usr/include/X11 include/
+          # cp -R /usr/include/xcb include/
+          # cp -R /usr/include/GL/* include/GL/
+          pip3 install mako
+          # -Dglx=gallium-xlib \
+          # -Dglx=dri
+          meson build-ios-aarch64 \
+            --prefix="/tmp/zink" \
+            --cross-file ios-aarch64 \
+            -Dmoltenvk-dir=../../../../MoltenVK/MoltenVK \
+            -Db_lundef=false \
+            -Dllvm=disabled \
+            -Dxlib-lease=disabled \
+            -Degl=disabled \
+            -Dgbm=disabled \
+            -Dglx=dri \
+            -Dglx-direct=true \
+            -Dopengl=true \
+            -Dosmesa=true \
+            -Dvulkan-drivers= \
+            -Dgallium-drivers=virgl
+          ninja -C build-ios-aarch64 install
+          # cp build-ios-aarch64/src/gallium/drivers/zink/libzink.a /tmp/zink/lib/
+          install_name_tool -change /tmp/zink/lib/libglapi.0.dylib @executable_path/Frameworks/libglapi.0.dylib.framework/libglapi.0.dylib -add_rpath @executable_path/Frameworks/libMoltenVK.dylib.framework /tmp/zink/lib/libOSMesa.8.dylib
+      - name: Upload libraries
+        uses: actions/upload-artifact@v2
+        with:
+          name: libzink
+          path: /tmp/zink
diff --git a/android-aarch64 b/android-aarch64
new file mode 100644
index 0000000..436c27e
--- /dev/null
+++ b/android-aarch64
@@ -0,0 +1,17 @@
+[binaries]
+ar = '/usr/local/lib/android/sdk/ndk-bundle/toolchains/llvm/prebuilt/linux-x86_64/bin/llvm-ar'
+c = ['ccache', '/usr/local/lib/android/sdk/ndk-bundle/toolchains/llvm/prebuilt/linux-x86_64/bin/aarch64-linux-android24-clang', '-O3', '-DVK_USE_PLATFORM_ANDROID_KHR', '-fPIC']
+cpp = ['ccache', '/usr/local/lib/android/sdk/ndk-bundle/toolchains/llvm/prebuilt/linux-x86_64/bin/aarch64-linux-android24-clang++', '-O3', '-DVK_USE_PLATFORM_ANDROID_KHR', '-fPIC', '-fno-exceptions', '-fno-unwind-tables', '-fno-asynchronous-unwind-tables', '-static-libstdc++']
+c_ld = 'lld'
+cpp_ld = 'lld'
+strip = '/usr/local/lib/android/sdk/ndk-bundle/toolchains/llvm/prebuilt/linux-x86_64/bin/aarch64-linux-android-strip'
+# Android doesn't come with a pkg-config, but we need one for meson to be happy not
+# finding all the optional deps it looks for.  Use system pkg-config pointing at a
+# directory we get to populate with any .pc files we want to add for Android
+pkgconfig = ['env', 'PKG_CONFIG_LIBDIR=/home/runner/work/mesa/mesa', '/usr/bin/pkg-config']
+
+[host_machine]
+system = 'linux'
+cpu_family = 'arm'
+cpu = 'armv8'
+endian = 'little'
diff --git a/android-arm32 b/android-arm32
new file mode 100644
index 0000000..80f5ecd
--- /dev/null
+++ b/android-arm32
@@ -0,0 +1,17 @@
+[binaries]
+ar = '/usr/local/lib/android/sdk/ndk-bundle/toolchains/llvm/prebuilt/linux-x86_64/bin/llvm-ar'
+c = ['ccache', '/usr/local/lib/android/sdk/ndk-bundle/toolchains/llvm/prebuilt/linux-x86_64/bin/armv7a-linux-androideabi24-clang', '-O3', '-DVK_USE_PLATFORM_ANDROID_KHR', '-fPIC']
+cpp = ['ccache', '/usr/local/lib/android/sdk/ndk-bundle/toolchains/llvm/prebuilt/linux-x86_64/bin/armv7a-linux-androideabi24-clang++', '-O3', '-DVK_USE_PLATFORM_ANDROID_KHR', '-fPIC', '-fno-exceptions', '-fno-unwind-tables', '-fno-asynchronous-unwind-tables', '-static-libstdc++']
+c_ld = 'lld'
+cpp_ld = 'lld'
+strip = '/usr/local/lib/android/sdk/ndk-bundle/toolchains/llvm/prebuilt/linux-x86_64/bin/arm-linux-androideabi29-strip'
+# Android doesn't come with a pkg-config, but we need one for meson to be happy not
+# finding all the optional deps it looks for.  Use system pkg-config pointing at a
+# directory we get to populate with any .pc files we want to add for Android
+pkgconfig = ['env', 'PKG_CONFIG_LIBDIR=/home/runner/work/mesa/mesa', '/usr/bin/pkg-config']
+
+[host_machine]
+system = 'linux'
+cpu_family = 'arm'
+cpu = 'armv7'
+endian = 'little'
diff --git a/android-x86_64 b/android-x86_64
new file mode 100644
index 0000000..6627d64
--- /dev/null
+++ b/android-x86_64
@@ -0,0 +1,22 @@
+[binaries]
+ar = '/usr/local/lib/android/sdk/ndk-bundle/toolchains/llvm/prebuilt/linux-x86_64/bin/llvm-ar'
+c = ['ccache', '/usr/local/lib/android/sdk/ndk-bundle/toolchains/llvm/prebuilt/linux-x86_64/bin/x86_64-linux-android24-clang', '-O3', '-DVK_USE_PLATFORM_ANDROID_KHR', '-fPIC']
+cpp = ['ccache', '/usr/local/lib/android/sdk/ndk-bundle/toolchains/llvm/prebuilt/linux-x86_64/bin/x86_64-linux-android24-clang++', '-O3', '-DVK_USE_PLATFORM_ANDROID_KHR', '-fPIC', '-fno-exceptions', '-fno-unwind-tables', '-fno-asynchronous-unwind-tables', '-static-libstdc++']
+c_ld = 'lld'
+cpp_ld = 'lld'
+strip = '/usr/local/lib/android/sdk/ndk-bundle/toolchains/llvm/prebuilt/linux-x86_64/bin/x86_64-linux-android-strip'
+# Android doesn't come with a pkg-config, but we need one for meson to be happy not
+# finding all the optional deps it looks for.  Use system pkg-config pointing at a
+# directory we get to populate with any .pc files we want to add for Android
+pkgconfig = ['env', 'PKG_CONFIG_LIBDIR=/home/runner/work/mesa/mesa', '/usr/bin/pkg-config']
+
+[host_machine]
+system = 'linux'
+# cpu_family = 'x86_64'
+# cpu = 'amd64'
+
+# ik this is wrong but workaround sanity check
+cpu_family = 'arm'
+cpu = 'armv8'
+
+endian = 'little'
diff --git a/ext/libMoltenVK.dylib b/ext/libMoltenVK.dylib
new file mode 100644
index 0000000..0f8455c
Binary files /dev/null and b/ext/libMoltenVK.dylib differ
diff --git a/include/MoltenVK/mvk_datatypes.h b/include/MoltenVK/mvk_datatypes.h
new file mode 100644
index 0000000..2ac2f49
--- /dev/null
+++ b/include/MoltenVK/mvk_datatypes.h
@@ -0,0 +1,487 @@
+/*
+ * mvk_datatypes.h
+ *
+ * Copyright (c) 2015-2021 The Brenwill Workshop Ltd. (http://www.brenwill.com)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+/* 
+ * This file contains functions for converting between Vulkan and Metal data types.
+ *
+ * The functions here are used internally by MoltenVK, and are exposed here 
+ * as a convenience for use elsewhere within applications using MoltenVK.
+ */
+
+#ifndef __mvkDataTypes_h_
+#define __mvkDataTypes_h_ 1
+
+#ifdef __cplusplus
+extern "C" {
+#endif	//  __cplusplus
+	
+#include "mvk_vulkan.h"
+
+#import <Metal/Metal.h>
+#import <CoreGraphics/CoreGraphics.h>
+
+
+#pragma mark -
+#pragma mark Image properties
+
+#pragma mark Texture formats
+
+/** Enumerates the data type of a format. */
+typedef enum {
+    kMVKFormatNone,             /**< Format type is unknown. */
+	kMVKFormatColorHalf,		/**< A 16-bit floating point color. */
+    kMVKFormatColorFloat,		/**< A 32-bit floating point color. */
+	kMVKFormatColorInt8,        /**< A signed 8-bit integer color. */
+	kMVKFormatColorUInt8,		/**< An unsigned 8-bit integer color. */
+	kMVKFormatColorInt16,       /**< A signed 16-bit integer color. */
+	kMVKFormatColorUInt16,		/**< An unsigned 16-bit integer color. */
+    kMVKFormatColorInt32,       /**< A signed 32-bit integer color. */
+    kMVKFormatColorUInt32,		/**< An unsigned 32-bit integer color. */
+    kMVKFormatDepthStencil,     /**< A depth and stencil value. */
+    kMVKFormatCompressed,       /**< A block-compressed color. */
+} MVKFormatType;
+
+/** Returns whether the VkFormat is supported by this implementation. */
+bool mvkVkFormatIsSupported(VkFormat vkFormat);
+
+/** Returns whether the MTLPixelFormat is supported by this implementation. */
+bool mvkMTLPixelFormatIsSupported(MTLPixelFormat mtlFormat);
+
+/** Returns the format type corresponding to the specified Vulkan VkFormat, */
+MVKFormatType mvkFormatTypeFromVkFormat(VkFormat vkFormat);
+
+/** Returns the format type corresponding to the specified Metal MTLPixelFormat, */
+MVKFormatType mvkFormatTypeFromMTLPixelFormat(MTLPixelFormat mtlFormat);
+
+/**
+ * Returns the Metal MTLPixelFormat corresponding to the specified Vulkan VkFormat,
+ * or returns MTLPixelFormatInvalid if no corresponding MTLPixelFormat exists.
+ *
+ * Not all MTLPixelFormats returned by this function are supported by all GPU's, 
+ * and, internally, MoltenVK may substitute and use a different MTLPixelFormat than
+ * is returned by this function for a particular Vulkan VkFormat value.
+ *
+ * Not all macOS GPU's support the MTLPixelFormatDepth24Unorm_Stencil8 pixel format.
+ * Even though this function will return that value when passed the corresponding 
+ * VkFormat value, internally, MoltenVK will use the MTLPixelFormatDepth32Float_Stencil8
+ * instead when a GPU does not support the MTLPixelFormatDepth24Unorm_Stencil8 pixel format.
+ * On an macOS device that has more than one GPU, one of the GPU's may support the
+ * MTLPixelFormatDepth24Unorm_Stencil8 pixel format while another may not.
+ */
+MTLPixelFormat mvkMTLPixelFormatFromVkFormat(VkFormat vkFormat);
+
+/**
+ * Returns the Vulkan VkFormat corresponding to the specified Metal MTLPixelFormat,
+ * or returns VK_FORMAT_UNDEFINED if no corresponding VkFormat exists.
+ */
+VkFormat mvkVkFormatFromMTLPixelFormat(MTLPixelFormat mtlFormat);
+
+/**
+ * Returns the size, in bytes, of a texel block of the specified Vulkan format.
+ * For uncompressed formats, the returned value corresponds to the size in bytes of a single texel.
+ */
+uint32_t mvkVkFormatBytesPerBlock(VkFormat vkFormat);
+
+/** 
+ * Returns the size, in bytes, of a texel block of the specified Metal format.
+ * For uncompressed formats, the returned value corresponds to the size in bytes of a single texel.
+ */
+uint32_t mvkMTLPixelFormatBytesPerBlock(MTLPixelFormat mtlFormat);
+
+/**
+ * Returns the size of the compression block, measured in texels for a Vulkan format.
+ * The returned value will be {1, 1} for non-compressed formats.
+ */
+VkExtent2D mvkVkFormatBlockTexelSize(VkFormat vkFormat);
+
+/**
+ * Returns the size of the compression block, measured in texels for a Metal format.
+ * The returned value will be {1, 1} for non-compressed formats.
+ */
+VkExtent2D mvkMTLPixelFormatBlockTexelSize(MTLPixelFormat mtlFormat);
+
+/**
+ * Returns the size, in bytes, of a texel of the specified Vulkan format.
+ * The returned value may be fractional for certain compressed formats.
+ */
+float mvkVkFormatBytesPerTexel(VkFormat vkFormat);
+
+/**
+ * Returns the size, in bytes, of a texel of the specified Metal format.
+ * The returned value may be fractional for certain compressed formats.
+ */
+float mvkMTLPixelFormatBytesPerTexel(MTLPixelFormat mtlFormat);
+
+/**
+ * Returns the size, in bytes, of a row of texels of the specified Vulkan format.
+ *
+ * For compressed formats, this takes into consideration the compression block size,
+ * and texelsPerRow should specify the width in texels, not blocks. The result is rounded
+ * up if texelsPerRow is not an integer multiple of the compression block width.
+ */
+size_t mvkVkFormatBytesPerRow(VkFormat vkFormat, uint32_t texelsPerRow);
+
+/**
+ * Returns the size, in bytes, of a row of texels of the specified Metal format.
+ *
+ * For compressed formats, this takes into consideration the compression block size,
+ * and texelsPerRow should specify the width in texels, not blocks. The result is rounded
+ * up if texelsPerRow is not an integer multiple of the compression block width.
+ */
+size_t mvkMTLPixelFormatBytesPerRow(MTLPixelFormat mtlFormat, uint32_t texelsPerRow);
+
+/**
+ * Returns the size, in bytes, of a texture layer of the specified Vulkan format.
+ *
+ * For compressed formats, this takes into consideration the compression block size,
+ * and texelRowsPerLayer should specify the height in texels, not blocks. The result is
+ * rounded up if texelRowsPerLayer is not an integer multiple of the compression block height.
+ */
+size_t mvkVkFormatBytesPerLayer(VkFormat vkFormat, size_t bytesPerRow, uint32_t texelRowsPerLayer);
+
+/**
+ * Returns the size, in bytes, of a texture layer of the specified Metal format.
+ * For compressed formats, this takes into consideration the compression block size,
+ * and texelRowsPerLayer should specify the height in texels, not blocks. The result is
+ * rounded up if texelRowsPerLayer is not an integer multiple of the compression block height.
+ */
+size_t mvkMTLPixelFormatBytesPerLayer(MTLPixelFormat mtlFormat, size_t bytesPerRow, uint32_t texelRowsPerLayer);
+
+/** Returns the default properties for the specified Vulkan format. */
+VkFormatProperties mvkVkFormatProperties(VkFormat vkFormat);
+
+/** Returns the name of the specified Vulkan format. */
+const char* mvkVkFormatName(VkFormat vkFormat);
+
+/** Returns the name of the specified Metal pixel format. */
+const char* mvkMTLPixelFormatName(MTLPixelFormat mtlFormat);
+
+/**
+ * Returns the MTLClearColor value corresponding to the color value in the VkClearValue,
+ * extracting the color value that is VkFormat for the VkFormat.
+ */
+MTLClearColor mvkMTLClearColorFromVkClearValue(VkClearValue vkClearValue,
+											   VkFormat vkFormat);
+
+/** Returns the Metal depth value corresponding to the depth value in the specified VkClearValue. */
+double mvkMTLClearDepthFromVkClearValue(VkClearValue vkClearValue);
+
+/** Returns the Metal stencil value corresponding to the stencil value in the specified VkClearValue. */
+uint32_t mvkMTLClearStencilFromVkClearValue(VkClearValue vkClearValue);
+
+/** Returns whether the specified Metal MTLPixelFormat can be used as a depth format. */
+bool mvkMTLPixelFormatIsDepthFormat(MTLPixelFormat mtlFormat);
+
+/** Returns whether the specified Metal MTLPixelFormat can be used as a stencil format. */
+bool mvkMTLPixelFormatIsStencilFormat(MTLPixelFormat mtlFormat);
+
+/** Returns whether the specified Metal MTLPixelFormat is a PVRTC format. */
+bool mvkMTLPixelFormatIsPVRTCFormat(MTLPixelFormat mtlFormat);
+
+/** Returns the Metal texture type from the specified Vulkan image properties. */
+MTLTextureType mvkMTLTextureTypeFromVkImageType(VkImageType vkImageType,
+												uint32_t arraySize,
+												bool isMultisample);
+
+/** Returns the Vulkan image type from the Metal texture type. */
+VkImageType mvkVkImageTypeFromMTLTextureType(MTLTextureType mtlTextureType);
+
+/** Returns the Metal MTLTextureType corresponding to the Vulkan VkImageViewType. */
+MTLTextureType mvkMTLTextureTypeFromVkImageViewType(VkImageViewType vkImageViewType, bool isMultisample);
+
+/** Returns the Metal texture usage from the Vulkan image usage taking into considertion usage limits for the pixel format. */
+MTLTextureUsage mvkMTLTextureUsageFromVkImageUsageFlags(VkImageUsageFlags vkImageUsageFlags, MTLPixelFormat mtlPixFmt);
+
+/** Returns the Vulkan image usage from the Metal texture usage and format. */
+VkImageUsageFlags mvkVkImageUsageFlagsFromMTLTextureUsage(MTLTextureUsage mtlUsage, MTLPixelFormat mtlFormat);
+
+/**
+ * Returns the numeric sample count corresponding to the specified Vulkan sample count flag.
+ *
+ * The specified flags value should have only one bit set, otherwise an invalid numeric value will be returned.
+ */
+uint32_t mvkSampleCountFromVkSampleCountFlagBits(VkSampleCountFlagBits vkSampleCountFlag);
+
+/** Returns the Vulkan bit flags corresponding to the numeric sample count, which must be a PoT value. */
+VkSampleCountFlagBits mvkVkSampleCountFlagBitsFromSampleCount(NSUInteger sampleCount);
+
+/** Returns the Metal texture swizzle from the Vulkan component swizzle. */
+MTLTextureSwizzle mvkMTLTextureSwizzleFromVkComponentSwizzle(VkComponentSwizzle vkSwizzle);
+
+/** Returns all four Metal texture swizzles from the Vulkan component mapping. */
+MTLTextureSwizzleChannels mvkMTLTextureSwizzleChannelsFromVkComponentMapping(VkComponentMapping vkMapping);
+
+
+#pragma mark Mipmaps
+
+/**
+ * Returns the number of mipmap levels available to an image with the specified side dimension.
+ * 
+ * If the specified dimension is a power-of-two, the value returned is (log2(dim) + 1).
+ * If the specified dimension is NOT a power-of-two, the value returned is 0, indicating
+ * that the image cannot support mipmaps.
+ */
+uint32_t mvkMipmapLevels(uint32_t dim);
+
+/**
+ * Returns the number of mipmap levels available to an image with the specified extent.
+ *
+ * If each dimension in the specified extent is a power-of-two, the value returned
+ * is MAX(log2(dim) + 1) across both dimensions. If either dimension in the specified 
+ * extent is NOT a power-of-two, the value returned is 1, indicating that the image 
+ * cannot support mipmaps, and that only the base mip level can be used.
+ */
+uint32_t mvkMipmapLevels2D(VkExtent2D extent);
+
+/**
+ * Returns the number of mipmap levels available to an image with the specified extent.
+ *
+ * If each dimension in the specified extent is a power-of-two, the value returned
+ * is MAX(log2(dim) + 1) across all dimensions. If either dimension in the specified
+ * extent is NOT a power-of-two, the value returned is 1, indicating that the image
+ * cannot support mipmaps, and that only the base mip level can be used.
+ */
+uint32_t mvkMipmapLevels3D(VkExtent3D extent);
+
+/** 
+ * Returns the size of the specified zero-based mipmap level, 
+ * when the size of the base level is the specified size. 
+ */
+VkExtent2D mvkMipmapLevelSizeFromBaseSize2D(VkExtent2D baseSize, uint32_t level);
+
+/**
+ * Returns the size of the specified zero-based mipmap level,
+ * when the size of the base level is the specified size.
+ */
+VkExtent3D mvkMipmapLevelSizeFromBaseSize3D(VkExtent3D baseSize, uint32_t level);
+
+/** 
+ * Returns the size of the mipmap base level, when the size of 
+ * the specified zero-based mipmap level is the specified size.
+ */
+VkExtent2D mvkMipmapBaseSizeFromLevelSize2D(VkExtent2D levelSize, uint32_t level);
+
+/**
+ * Returns the size of the mipmap base level, when the size of
+ * the specified zero-based mipmap level is the specified size.
+ */
+VkExtent3D mvkMipmapBaseSizeFromLevelSize3D(VkExtent3D levelSize, uint32_t level);
+
+
+#pragma mark Samplers
+
+/**
+ * Returns the Metal MTLSamplerAddressMode corresponding to the specified Vulkan VkSamplerAddressMode,
+ * or returns MTLSamplerAddressModeMirrorClampToEdge if no corresponding MTLSamplerAddressMode exists.
+ */
+MTLSamplerAddressMode mvkMTLSamplerAddressModeFromVkSamplerAddressMode(VkSamplerAddressMode vkMode);
+
+#if MVK_MACOS_OR_IOS 
+/**
+ * Returns the Metal MTLSamplerBorderColor corresponding to the specified Vulkan VkBorderColor,
+ * or returns MTLSamplerBorderColorTransparentBlack if no corresponding MTLSamplerBorderColor exists.
+ */
+MTLSamplerBorderColor mvkMTLSamplerBorderColorFromVkBorderColor(VkBorderColor vkColor);
+#endif
+
+/**
+ * Returns the Metal MTLSamplerMinMagFilter corresponding to the specified Vulkan VkFilter,
+ * or returns MTLSamplerMinMagFilterNearest if no corresponding MTLSamplerMinMagFilter exists.
+ */
+MTLSamplerMinMagFilter mvkMTLSamplerMinMagFilterFromVkFilter(VkFilter vkFilter);
+
+/**
+ * Returns the Metal MTLSamplerMipFilter corresponding to the specified Vulkan VkSamplerMipmapMode,
+ * or returns MTLSamplerMipFilterNotMipmapped if no corresponding MTLSamplerMipFilter exists.
+ */
+MTLSamplerMipFilter mvkMTLSamplerMipFilterFromVkSamplerMipmapMode(VkSamplerMipmapMode vkMode);
+
+
+#pragma mark -
+#pragma mark Render pipeline
+
+/** Identifies a particular shading stage in a pipeline. */
+typedef enum {
+	kMVKShaderStageVertex = 0,
+	kMVKShaderStageTessCtl,
+	kMVKShaderStageTessEval,
+	kMVKShaderStageFragment,
+	kMVKShaderStageCompute,
+	kMVKShaderStageMax
+} MVKShaderStage;
+
+/** Returns the Metal MTLColorWriteMask corresponding to the specified Vulkan VkColorComponentFlags. */
+MTLColorWriteMask mvkMTLColorWriteMaskFromVkChannelFlags(VkColorComponentFlags vkWriteFlags);
+
+/** Returns the Metal MTLBlendOperation corresponding to the specified Vulkan VkBlendOp. */
+MTLBlendOperation mvkMTLBlendOperationFromVkBlendOp(VkBlendOp vkBlendOp);
+
+/** Returns the Metal MTLBlendFactor corresponding to the specified Vulkan VkBlendFactor. */
+MTLBlendFactor mvkMTLBlendFactorFromVkBlendFactor(VkBlendFactor vkBlendFactor);
+
+/**
+ * Returns the Metal MTLVertexFormat corresponding to the specified
+ * Vulkan VkFormat as used as a vertex attribute format.
+ */
+MTLVertexFormat mvkMTLVertexFormatFromVkFormat(VkFormat vkFormat);
+
+/** Returns the Metal MTLVertexStepFunction corresponding to the specified Vulkan VkVertexInputRate. */
+MTLVertexStepFunction mvkMTLVertexStepFunctionFromVkVertexInputRate(VkVertexInputRate vkVtxStep);
+
+/** Returns the Metal MTLStepFunction corresponding to the specified Vulkan VkVertexInputRate. */
+MTLStepFunction mvkMTLStepFunctionFromVkVertexInputRate(VkVertexInputRate vkVtxStep, bool forTess = false);
+
+/** Returns the Metal MTLPrimitiveType corresponding to the specified Vulkan VkPrimitiveTopology. */
+MTLPrimitiveType mvkMTLPrimitiveTypeFromVkPrimitiveTopology(VkPrimitiveTopology vkTopology);
+
+/** Returns the Metal MTLPrimitiveTopologyClass corresponding to the specified Vulkan VkPrimitiveTopology. */
+MTLPrimitiveTopologyClass mvkMTLPrimitiveTopologyClassFromVkPrimitiveTopology(VkPrimitiveTopology vkTopology);
+
+/** Returns the Metal MTLTriangleFillMode corresponding to the specified Vulkan VkPolygonMode, */
+MTLTriangleFillMode mvkMTLTriangleFillModeFromVkPolygonMode(VkPolygonMode vkFillMode);
+
+/** Returns the Metal MTLLoadAction corresponding to the specified Vulkan VkAttachmentLoadOp. */
+MTLLoadAction mvkMTLLoadActionFromVkAttachmentLoadOp(VkAttachmentLoadOp vkLoadOp);
+
+/** Returns the Metal MTLStoreAction corresponding to the specified Vulkan VkAttachmentStoreOp. */
+MTLStoreAction mvkMTLStoreActionFromVkAttachmentStoreOp(VkAttachmentStoreOp vkStoreOp, bool hasResolveAttachment);
+
+/** Returns the Metal MTLMultisampleDepthResolveFilter corresponding to the specified Vulkan VkResolveModeFlagBits. */
+MTLMultisampleDepthResolveFilter mvkMTLMultisampleDepthResolveFilterFromVkResolveModeFlagBits(VkResolveModeFlagBits vkResolveMode);
+
+#if MVK_MACOS_OR_IOS
+/** Returns the Metal MTLMultisampleStencilResolveFilter corresponding to the specified Vulkan VkResolveModeFlagBits. */
+MTLMultisampleStencilResolveFilter mvkMTLMultisampleStencilResolveFilterFromVkResolveModeFlagBits(VkResolveModeFlagBits vkResolveMode);
+#endif
+
+/** Returns the Metal MTLViewport corresponding to the specified Vulkan VkViewport. */
+MTLViewport mvkMTLViewportFromVkViewport(VkViewport vkViewport);
+
+/** Returns the Metal MTLScissorRect corresponding to the specified Vulkan VkRect2D. */
+MTLScissorRect mvkMTLScissorRectFromVkRect2D(VkRect2D vkRect);
+
+/** Returns the Metal MTLCompareFunction corresponding to the specified Vulkan VkCompareOp, */
+MTLCompareFunction mvkMTLCompareFunctionFromVkCompareOp(VkCompareOp vkOp);
+
+/** Returns the Metal MTLStencilOperation corresponding to the specified Vulkan VkStencilOp, */
+MTLStencilOperation mvkMTLStencilOperationFromVkStencilOp(VkStencilOp vkOp);
+
+/** Returns the Metal MTLCullMode corresponding to the specified Vulkan VkCullModeFlags, */
+MTLCullMode mvkMTLCullModeFromVkCullModeFlags(VkCullModeFlags vkCull);
+
+/** Returns the Metal MTLWinding corresponding to the specified Vulkan VkFrontFace, */
+MTLWinding mvkMTLWindingFromVkFrontFace(VkFrontFace vkWinding);
+
+/** Returns the Metal MTLIndexType corresponding to the specified Vulkan VkIndexType, */
+MTLIndexType mvkMTLIndexTypeFromVkIndexType(VkIndexType vkIdxType);
+
+/** Returns the size, in bytes, of a vertex index of the specified type. */
+size_t mvkMTLIndexTypeSizeInBytes(MTLIndexType mtlIdxType);
+
+/** Returns the MoltenVK MVKShaderStage corresponding to the specified Vulkan VkShaderStageFlagBits. */
+MVKShaderStage mvkShaderStageFromVkShaderStageFlagBits(VkShaderStageFlagBits vkStage);
+
+/** Returns the Vulkan VkShaderStageFlagBits corresponding to the specified MoltenVK MVKShaderStage. */
+VkShaderStageFlagBits mvkVkShaderStageFlagBitsFromMVKShaderStage(MVKShaderStage mvkStage);
+
+/** Returns the Metal MTLWinding corresponding to the specified SPIR-V spv::ExecutionMode. */
+MTLWinding mvkMTLWindingFromSpvExecutionMode(uint32_t spvMode);
+
+/** Returns the Metal MTLTessellationPartitionMode corresponding to the specified SPIR-V spv::ExecutionMode. */
+MTLTessellationPartitionMode mvkMTLTessellationPartitionModeFromSpvExecutionMode(uint32_t spvMode);
+
+/**
+ * Returns the combination of Metal MTLRenderStage bits corresponding to the specified Vulkan VkPiplineStageFlags,
+ * taking into consideration whether the barrier is to be placed before or after the specified pipeline stages.
+ */
+MTLRenderStages mvkMTLRenderStagesFromVkPipelineStageFlags(VkPipelineStageFlags vkStages, bool placeBarrierBefore);
+
+/** Returns the combination of Metal MTLBarrierScope bits corresponding to the specified Vulkan VkAccessFlags. */
+MTLBarrierScope mvkMTLBarrierScopeFromVkAccessFlags(VkAccessFlags vkAccess);
+
+#pragma mark -
+#pragma mark Geometry conversions
+
+/** Returns a VkExtent2D that corresponds to the specified CGSize. */
+static inline VkExtent2D mvkVkExtent2DFromCGSize(CGSize cgSize) {
+	VkExtent2D vkExt;
+	vkExt.width = cgSize.width;
+	vkExt.height = cgSize.height;
+	return vkExt;
+}
+
+/** Returns a CGSize that corresponds to the specified VkExtent2D. */
+static inline CGSize mvkCGSizeFromVkExtent2D(VkExtent2D vkExtent) {
+	CGSize cgSize;
+	cgSize.width = vkExtent.width;
+	cgSize.height = vkExtent.height;
+	return cgSize;
+}
+
+/** Returns a Metal MTLOrigin constructed from a VkOffset3D. */
+static inline MTLOrigin mvkMTLOriginFromVkOffset3D(VkOffset3D vkOffset) {
+	return MTLOriginMake(vkOffset.x, vkOffset.y, vkOffset.z);
+}
+
+/** Returns a Vulkan VkOffset3D constructed from a Metal MTLOrigin. */
+static inline VkOffset3D mvkVkOffset3DFromMTLSize(MTLOrigin mtlOrigin) {
+	return { (int32_t)mtlOrigin.x, (int32_t)mtlOrigin.y, (int32_t)mtlOrigin.z };
+}
+
+/** Returns a Metal MTLSize constructed from a VkExtent3D. */
+static inline MTLSize mvkMTLSizeFromVkExtent3D(VkExtent3D vkExtent) {
+	return MTLSizeMake(vkExtent.width, vkExtent.height, vkExtent.depth);
+}
+
+/** Returns a Vulkan VkExtent3D  constructed from a Metal MTLSize. */
+static inline VkExtent3D mvkVkExtent3DFromMTLSize(MTLSize mtlSize) {
+	return { (uint32_t)mtlSize.width, (uint32_t)mtlSize.height, (uint32_t)mtlSize.depth };
+}
+
+
+#pragma mark -
+#pragma mark Memory options
+
+/** Macro indicating the Vulkan memory type bits corresponding to Metal private memory (not host visible). */
+#define MVK_VK_MEMORY_TYPE_METAL_PRIVATE	(VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT)
+
+/** Macro indicating the Vulkan memory type bits corresponding to Metal shared memory (host visible and coherent). */
+#define MVK_VK_MEMORY_TYPE_METAL_SHARED		(VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT | VK_MEMORY_PROPERTY_HOST_CACHED_BIT)
+
+/** Macro indicating the Vulkan memory type bits corresponding to Metal managed memory (host visible and non-coherent). */
+#define MVK_VK_MEMORY_TYPE_METAL_MANAGED	(VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT | VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_CACHED_BIT)
+
+/** Macro indicating the Vulkan memory type bits corresponding to Metal memoryless memory (not host visible and lazily allocated). */
+#define MVK_VK_MEMORY_TYPE_METAL_MEMORYLESS	(VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT | VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT)
+
+/** Returns the Metal storage mode corresponding to the specified Vulkan memory flags. */
+MTLStorageMode mvkMTLStorageModeFromVkMemoryPropertyFlags(VkMemoryPropertyFlags vkFlags);
+
+/** Returns the Metal CPU cache mode corresponding to the specified Vulkan memory flags. */
+MTLCPUCacheMode mvkMTLCPUCacheModeFromVkMemoryPropertyFlags(VkMemoryPropertyFlags vkFlags);
+
+/** Returns the Metal resource option flags corresponding to the Metal storage mode and cache mode. */
+MTLResourceOptions mvkMTLResourceOptions(MTLStorageMode mtlStorageMode, MTLCPUCacheMode mtlCPUCacheMode);
+
+
+#ifdef __cplusplus
+}
+#endif	//  __cplusplus
+
+#endif
diff --git a/include/MoltenVK/mvk_vulkan.h b/include/MoltenVK/mvk_vulkan.h
new file mode 100644
index 0000000..20a8f2f
--- /dev/null
+++ b/include/MoltenVK/mvk_vulkan.h
@@ -0,0 +1,50 @@
+/*
+ * mvk_vulkan.h
+ *
+ * Copyright (c) 2015-2021 The Brenwill Workshop Ltd. (http://www.brenwill.com)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+/** 
+ * This is a convenience header file that loads vulkan.h with the appropriate Vulkan platform extensions.
+ *
+ * This header automatically enables the VK_EXT_metal_surface Vulkan extension.
+ *
+ * When building for iOS, this header also automatically enables the obsolete VK_MVK_ios_surface Vulkan extension.
+ * When building for macOS, this header also automatically enables the obsolete VK_MVK_macos_surface Vulkan extension.
+ * Both of these extensions are obsolete. Consider using the portable VK_EXT_metal_surface extension instead.
+ */
+
+#ifndef __mvk_vulkan_h_
+#define __mvk_vulkan_h_ 1
+
+
+#include <Availability.h>
+
+#define VK_USE_PLATFORM_METAL_EXT				1
+
+#define VK_ENABLE_BETA_EXTENSIONS				1		// VK_KHR_portability_subset
+
+#ifdef __IPHONE_OS_VERSION_MAX_ALLOWED
+#	define VK_USE_PLATFORM_IOS_MVK				1
+#endif
+
+#ifdef __MAC_OS_X_VERSION_MAX_ALLOWED
+#	define VK_USE_PLATFORM_MACOS_MVK			1
+#endif
+
+#include <vulkan/vulkan.h>
+
+#endif
diff --git a/include/MoltenVK/vk_mvk_moltenvk.h b/include/MoltenVK/vk_mvk_moltenvk.h
new file mode 100644
index 0000000..c549151
--- /dev/null
+++ b/include/MoltenVK/vk_mvk_moltenvk.h
@@ -0,0 +1,1216 @@
+/*
+ * vk_mvk_moltenvk.h
+ *
+ * Copyright (c) 2015-2021 The Brenwill Workshop Ltd. (http://www.brenwill.com)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+/** Vulkan extension VK_MVK_moltenvk. */
+
+#ifndef __vk_mvk_moltenvk_h_
+#define __vk_mvk_moltenvk_h_ 1
+
+#ifdef __cplusplus
+extern "C" {
+#endif	//  __cplusplus
+	
+#include "mvk_vulkan.h"
+
+#ifdef __OBJC__
+#import <Metal/Metal.h>
+#import <IOSurface/IOSurfaceRef.h>
+#else
+typedef unsigned long MTLLanguageVersion;
+#endif
+
+
+/**
+ * The version number of MoltenVK is a single integer value, derived from the Major, Minor,
+ * and Patch version values, where each of the Major, Minor, and Patch components is allocated
+ * two decimal digits, in the format MjMnPt. This creates a version number that is both human
+ * readable and allows efficient computational comparisons to a single integer number.
+ *
+ * The following examples illustrate how the MoltenVK version number is built from its components:
+ *   - 002000    (version 0.20.0)
+ *   - 010000    (version 1.0.0)
+ *   - 030104    (version 3.1.4)
+ *   - 401215    (version 4.12.15)
+ */
+#define MVK_VERSION_MAJOR   1
+#define MVK_VERSION_MINOR   1
+#define MVK_VERSION_PATCH   2
+
+#define MVK_MAKE_VERSION(major, minor, patch)    (((major) * 10000) + ((minor) * 100) + (patch))
+#define MVK_VERSION     MVK_MAKE_VERSION(MVK_VERSION_MAJOR, MVK_VERSION_MINOR, MVK_VERSION_PATCH)
+
+#define VK_MVK_MOLTENVK_SPEC_VERSION            30
+#define VK_MVK_MOLTENVK_EXTENSION_NAME          "VK_MVK_moltenvk"
+
+/**
+ * MoltenVK configuration settings.
+ *
+ * To be active, some configuration settings must be set before a VkDevice is created.
+ * See the description of the individual configuration structure members for more information.
+ *
+ * There are three mechanisms for setting the values of the MoltenVK configuration parameters:
+ *   - Runtime API via the vkGetMoltenVKConfigurationMVK()/vkSetMoltenVKConfigurationMVK() functions.
+ *   - Application runtime environment variables.
+ *   - Build settings at MoltenVK build time.
+ *
+ * To change the MoltenVK configuration settings at runtime using a programmatic API,
+ * use the vkGetMoltenVKConfigurationMVK() and vkSetMoltenVKConfigurationMVK() functions
+ * to retrieve, modify, and set a copy of the MVKConfiguration structure. To be active,
+ * some configuration settings must be set before a VkInstance or VkDevice is created.
+ * See the description of each member for more information.
+ *
+ * The initial value of each of the configuration settings can established at runtime
+ * by a corresponding environment variable, or if the environment variable is not set,
+ * by a corresponding build setting at the time MoltenVK is compiled. The environment
+ * variable and build setting for each configuration parameter share the same name.
+ *
+ * For example, the initial value of the shaderConversionFlipVertexY configuration setting
+ * is set by the MVK_CONFIG_SHADER_CONVERSION_FLIP_VERTEX_Y at runtime, or by the
+ * MVK_CONFIG_SHADER_CONVERSION_FLIP_VERTEX_Y build setting when MoltenVK is compiled.
+ *
+ * This structure may be extended as new features are added to MoltenVK. If you are linking to
+ * an implementation of MoltenVK that was compiled from a different VK_MVK_MOLTENVK_SPEC_VERSION
+ * than your app was, the size of this structure in your app may be larger or smaller than the
+ * struct in MoltenVK. See the description of the vkGetMoltenVKConfigurationMVK() and
+ * vkSetMoltenVKConfigurationMVK() functions for information about how to handle this.
+ *
+ * TO SUPPORT DYNAMIC LINKING TO THIS STRUCTURE AS DESCRIBED ABOVE, THIS STRUCTURE SHOULD NOT
+ * BE CHANGED EXCEPT TO ADD ADDITIONAL MEMBERS ON THE END. EXISTING MEMBERS, AND THEIR ORDER,
+ * SHOULD NOT BE CHANGED.
+ */
+typedef struct {
+
+	/**
+	 * If enabled, debugging capabilities will be enabled, including logging
+	 * shader code during runtime shader conversion.
+	 *
+	 * The value of this parameter may be changed at any time during application runtime,
+	 * and the changed value will immediately effect subsequent MoltenVK behaviour.
+	 *
+	 * The initial value or this parameter is set by the
+	 * MVK_DEBUG
+	 * runtime environment variable or MoltenVK compile-time build setting.
+	 * If neither is set, the value of this parameter is false if MoltenVK was
+	 * built in Release mode, and true if MoltenVK was built in Debug mode.
+	 */
+    VkBool32 debugMode;
+
+	/**
+	 * If enabled, MSL vertex shader code created during runtime shader conversion will
+	 * flip the Y-axis of each vertex, as the Vulkan Y-axis is the inverse of OpenGL.
+	 *
+	 * An alternate way to reverse the Y-axis is to employ a negative Y-axis value on
+	 * the viewport, in which case this parameter can be disabled.
+	 *
+	 * The value of this parameter may be changed at any time during application runtime,
+	 * and the changed value will immediately effect subsequent MoltenVK behaviour.
+	 * Specifically, this parameter can be enabled when compiling some pipelines,
+	 * and disabled when compiling others. Existing pipelines are not automatically
+	 * re-compiled when this parameter is changed.
+	 *
+	 * The initial value or this parameter is set by the
+	 * MVK_CONFIG_SHADER_CONVERSION_FLIP_VERTEX_Y
+	 * runtime environment variable or MoltenVK compile-time build setting.
+	 * If neither is set, the value of this parameter defaults to true.
+	 */
+    VkBool32 shaderConversionFlipVertexY;
+
+	/**
+	 * If enabled, queue command submissions (vkQueueSubmit() & vkQueuePresentKHR()) will be
+	 * processed on the thread that called the submission function. If disabled, processing
+	 * will be dispatched to a GCD dispatch_queue whose priority is determined by
+	 * VkDeviceQueueCreateInfo::pQueuePriorities during vkCreateDevice().
+	 *
+	 * The value of this parameter must be changed before creating a VkDevice,
+	 * for the change to take effect.
+	 *
+	 * The initial value or this parameter is set by the
+	 * MVK_CONFIG_SYNCHRONOUS_QUEUE_SUBMITS
+	 * runtime environment variable or MoltenVK compile-time build setting.
+	 * If neither is set, the value of this parameter defaults to true for macOS 10.14
+	 * and above or iOS 12 and above, and false otherwise. The reason for this distinction
+	 * is that this feature should be disabled when emulation is required to support VkEvents
+	 * because native support for events (MTLEvent) is not available.
+	 */
+	VkBool32 synchronousQueueSubmits;
+
+	/**
+	 * If enabled, where possible, a Metal command buffer will be created and filled when each
+	 * Vulkan command buffer is filled. For applications that parallelize the filling of Vulkan
+	 * commmand buffers across multiple threads, this allows the Metal command buffers to also
+	 * be filled on the same parallel thread. Because each command buffer is filled separately,
+	 * this requires that each Vulkan command buffer requires a dedicated Metal command buffer.
+	 *
+	 * If disabled, a single Metal command buffer will be created and filled when the Vulkan
+	 * command buffers are submitted to the Vulkan queue. This allows a single Metal command
+	 * buffer to be used for all of the Vulkan command buffers in a queue submission. The
+	 * Metal command buffer is filled on the thread that processes the command queue submission.
+	 *
+	 * Depending on the nature of your application, you may find performance is improved by filling
+	 * the Metal command buffers on parallel threads, or you may find that performance is improved by
+	 * consolidating all Vulkan command buffers onto a single Metal command buffer during queue submission.
+	 *
+	 * Prefilling of a Metal command buffer will not occur during the filling of secondary command
+	 * buffers (VK_COMMAND_BUFFER_LEVEL_SECONDARY), or for primary command buffers that are intended
+	 * to be submitted to multiple queues concurrently (VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT).
+	 *
+	 * When enabling this feature, be aware that one Metal command buffer is required for each Vulkan
+	 * command buffer. Depending on the number of command buffers that you use, you may also need to
+	 * change the value of the maxActiveMetalCommandBuffersPerQueue setting.
+	 *
+	 * If this feature is enabled, be aware that if you have recorded commands to a Vulkan command buffer,
+	 * and then choose to reset that command buffer instead of submitting it, the corresponding prefilled
+	 * Metal command buffer will still be submitted. This is because Metal command buffers do not support
+	 * the concept of being reset after being filled. Depending on when and how often you do this,
+	 * it may cause unexpected visual artifacts and unnecessary GPU load.
+	 *
+	 * This feature is incompatible with updating descriptors after binding. If any of the
+	 * *UpdateAfterBind feature flags of VkPhysicalDeviceDescriptorIndexingFeaturesEXT or
+	 * VkPhysicalDeviceInlineUniformBlockFeaturesEXT have been enabled, the value of this
+	 * setting will be ignored and treated as if it is false.
+	 *
+	 * The value of this parameter may be changed at any time during application runtime,
+	 * and the changed value will immediately effect subsequent MoltenVK behaviour.
+	 * Specifically, this parameter can be enabled when filling some command buffers,
+	 * and disabled when filling others.
+	 *
+	 * The initial value or this parameter is set by the
+	 * MVK_CONFIG_PREFILL_METAL_COMMAND_BUFFERS
+	 * runtime environment variable or MoltenVK compile-time build setting.
+	 * If neither is set, the value of this parameter defaults to false.
+	 */
+	VkBool32 prefillMetalCommandBuffers;
+
+	/**
+	 * The maximum number of Metal command buffers that can be concurrently active per Vulkan queue.
+	 * The number of active Metal command buffers required depends on the prefillMetalCommandBuffers
+	 * setting. If prefillMetalCommandBuffers is enabled, one Metal command buffer is required per
+	 * Vulkan command buffer. If prefillMetalCommandBuffers is disabled, one Metal command buffer
+	 * is required per command buffer queue submission, which may be significantly less than the
+	 * number of Vulkan command buffers.
+	 *
+	 * The value of this parameter must be changed before creating a VkDevice,
+	 * for the change to take effect.
+	 *
+	 * The initial value or this parameter is set by the
+	 * MVK_CONFIG_MAX_ACTIVE_METAL_COMMAND_BUFFERS_PER_QUEUE
+	 * runtime environment variable or MoltenVK compile-time build setting.
+	 * If neither is set, the value of this parameter defaults to 64.
+	 */
+	uint32_t maxActiveMetalCommandBuffersPerQueue;
+
+	/**
+	 * Metal allows only 8192 occlusion queries per MTLBuffer. If enabled, MoltenVK
+	 * allocates a MTLBuffer for each query pool, allowing each query pool to support
+	 * 8192 queries, which may slow performance or cause unexpected behaviour if the query
+	 * pool is not established prior to a Metal renderpass, or if the query pool is changed
+	 * within a renderpass. If disabled, one MTLBuffer will be shared by all query pools,
+	 * which improves performance, but limits the total device queries to 8192.
+	 *
+	 * The value of this parameter may be changed at any time during application runtime,
+	 * and the changed value will immediately effect subsequent MoltenVK behaviour.
+	 * Specifically, this parameter can be enabled when creating some query pools,
+	 * and disabled when creating others.
+	 *
+	 * The initial value or this parameter is set by the
+	 * MVK_CONFIG_SUPPORT_LARGE_QUERY_POOLS
+	 * runtime environment variable or MoltenVK compile-time build setting.
+	 * If neither is set, the value of this parameter defaults to true.
+	 */
+	VkBool32 supportLargeQueryPools;
+
+	/** Obsolete, ignored, and deprecated. All surface presentations are performed with a command buffer. */
+	VkBool32 presentWithCommandBuffer;
+
+	/**
+	 * If enabled, swapchain images will use simple Nearest sampling when magnifying the
+	 * swapchain image to fit a physical display surface. If disabled, swapchain images will
+	 * use Linear sampling when magnifying the swapchain image to fit a physical display surface.
+	 * Enabling this setting avoids smearing effects when swapchain images are simple interger
+	 * multiples of display pixels (eg- macOS Retina, and typical of graphics apps and games),
+	 * but may cause aliasing effects when using non-integer display scaling.
+	 *
+	 * The value of this parameter may be changed before creating a VkSwapchain,
+	 * for the change to take effect.
+	 *
+	 * The initial value or this parameter is set by the
+	 * MVK_CONFIG_SWAPCHAIN_MAG_FILTER_USE_NEAREST
+	 * runtime environment variable or MoltenVK compile-time build setting.
+	 * If neither is set, the value of this parameter defaults to true.
+	 */
+	VkBool32 swapchainMagFilterUseNearest;
+
+	/**
+	 * The maximum amount of time, in nanoseconds, to wait for a Metal library, function, or
+	 * pipeline state object to be compiled and created by the Metal compiler. An internal error
+	 * within the Metal compiler can stall the thread for up to 30 seconds. Setting this value
+	 * limits that delay to a specified amount of time, allowing shader compilations to fail fast.
+	 *
+	 * The value of this parameter may be changed at any time during application runtime,
+	 * and the changed value will immediately effect subsequent MoltenVK behaviour.
+	 *
+	 * The initial value or this parameter is set by the
+	 * MVK_CONFIG_METAL_COMPILE_TIMEOUT
+	 * runtime environment variable or MoltenVK compile-time build setting.
+	 * If neither is set, the value of this parameter defaults to infinite.
+	 */
+	uint64_t metalCompileTimeout;
+
+	/**
+	 * If enabled, performance statistics, as defined by the MVKPerformanceStatistics structure,
+	 * are collected, and can be retrieved via the vkGetPerformanceStatisticsMVK() function.
+	 *
+	 * You can also use the performanceLoggingFrameCount or logActivityPerformanceInline
+	 * parameters to automatically log the performance statistics collected by this parameter.
+	 *
+	 * The value of this parameter must be changed before creating a VkDevice,
+	 * for the change to take effect.
+	 *
+	 * The initial value or this parameter is set by the
+	 * MVK_CONFIG_PERFORMANCE_TRACKING
+	 * runtime environment variable or MoltenVK compile-time build setting.
+	 * If neither is set, the value of this parameter defaults to false.
+	 */
+	VkBool32 performanceTracking;
+
+	/**
+	 * If non-zero, performance statistics, frame-based statistics will be logged, on a
+	 * repeating cycle, once per this many frames. The performanceTracking parameter must
+	 * also be enabled. If this parameter is zero, or the performanceTracking parameter
+	 * is disabled, no frame-based performance statistics will be logged.
+	 *
+	 * The value of this parameter may be changed at any time during application runtime,
+	 * and the changed value will immediately effect subsequent MoltenVK behaviour.
+	 *
+	 * The initial value or this parameter is set by the
+	 * MVK_CONFIG_PERFORMANCE_LOGGING_FRAME_COUNT
+	 * runtime environment variable or MoltenVK compile-time build setting.
+	 * If neither is set, the value of this parameter defaults to zero.
+	 */
+	uint32_t performanceLoggingFrameCount;
+
+	/**
+	 * If enabled, a MoltenVK logo watermark will be rendered on top of the scene.
+	 * This can be enabled for publicity during demos.
+	 *
+	 * The value of this parameter may be changed at any time during application runtime,
+	 * and the changed value will immediately effect subsequent MoltenVK behaviour.
+	 *
+	 * The initial value or this parameter is set by the
+	 * MVK_CONFIG_DISPLAY_WATERMARK
+	 * runtime environment variable or MoltenVK compile-time build setting.
+	 * If neither is set, the value of this parameter defaults to false.
+	 */
+	VkBool32 displayWatermark;
+
+	/**
+	 * Metal does not distinguish functionality between queues, which would normally mean only
+	 * a single general-purpose queue family with multiple queues is needed. However, Vulkan
+	 * associates command buffers with a queue family, whereas Metal associates command buffers
+	 * with a specific Metal queue. In order to allow a Metal command buffer to be prefilled
+	 * before is is formally submitted to a Vulkan queue, each Vulkan queue family can support
+	 * only a single Metal queue. As a result, in order to provide parallel queue operations,
+	 * MoltenVK provides multiple queue families, each with a single queue.
+	 *
+	 * If this parameter is disabled, all queue families will be advertised as having general-purpose
+	 * graphics + compute + transfer functionality, which is how the actual Metal queues behave.
+	 *
+	 * If this parameter is enabled, one queue family will be advertised as having general-purpose
+	 * graphics + compute + transfer functionality, and the remaining queue families will be advertised
+	 * as having specialized graphics OR compute OR transfer functionality, to make it easier for some
+	 * apps to select a queue family with the appropriate requirements.
+	 *
+	 * The value of this parameter must be changed before creating a VkDevice, and before
+	 * querying a VkPhysicalDevice for queue family properties, for the change to take effect.
+	 *
+	 * The initial value or this parameter is set by the
+	 * MVK_CONFIG_SPECIALIZED_QUEUE_FAMILIES
+	 * runtime environment variable or MoltenVK compile-time build setting.
+	 * If neither is set, the value of this parameter defaults to false.
+	 */
+	VkBool32 specializedQueueFamilies;
+
+	/**
+	 * If enabled, when the app creates a VkDevice from a VkPhysicalDevice (GPU) that is neither
+	 * headless nor low-power, and is different than the GPU used by the windowing system, the
+	 * windowing system will be forced to switch to use the GPU selected by the Vulkan app.
+	 * When the Vulkan app is ended, the windowing system will automatically switch back to
+	 * using the previous GPU, depending on the usage requirements of other running apps.
+	 *
+	 * If disabled, the Vulkan app will render using its selected GPU, and if the windowing
+	 * system uses a different GPU, the windowing system compositor will automatically copy
+	 * framebuffer content from the app GPU to the windowing system GPU.
+	 *
+	 * The value of this parmeter has no effect on systems with a single GPU, or when the
+	 * Vulkan app creates a VkDevice from a low-power or headless VkPhysicalDevice (GPU).
+	 *
+	 * Switching the windowing system GPU to match the Vulkan app GPU maximizes app performance,
+	 * because it avoids the windowing system compositor from having to copy framebuffer content
+	 * between GPUs on each rendered frame. However, doing so forces the entire system to
+	 * potentially switch to using a GPU that may consume more power while the app is running.
+	 *
+	 * Some Vulkan apps may want to render using a high-power GPU, but leave it up to the
+	 * system window compositor to determine how best to blend content with the windowing
+	 * system, and as a result, may want to disable this parameter.
+	 *
+	 * The value of this parameter must be changed before creating a VkDevice,
+	 * for the change to take effect.
+	 *
+	 * The initial value or this parameter is set by the
+	 * MVK_CONFIG_SWITCH_SYSTEM_GPU
+	 * runtime environment variable or MoltenVK compile-time build setting.
+	 * If neither is set, the value of this parameter defaults to true.
+	 */
+	VkBool32 switchSystemGPU;
+
+	/**
+	 * If enabled, arbitrary VkImageView component swizzles are supported, as defined
+	 * in VkImageViewCreateInfo::components when creating a VkImageView.
+	 *
+	 * If disabled, a very limited set of VkImageView component swizzles are supported
+	 * via format substitutions.
+	 *
+	 * Metal does not natively support per-texture swizzling. If this parameter is enabled
+	 * both when a VkImageView is created, and when any pipeline that uses that VkImageView
+	 * is compiled, VkImageView swizzling is automatically performed in the converted Metal
+	 * shader code during all texture sampling and reading operations, regardless of whether
+	 * a swizzle is required for the VkImageView associated with the Metal texture.
+	 * This may result in reduced performance.
+	 *
+	 * The value of this parameter may be changed at any time during application runtime,
+	 * and the changed value will immediately effect subsequent MoltenVK behaviour.
+	 * Specifically, this parameter can be enabled when creating VkImageViews that need it,
+	 * and compiling pipelines that use those VkImageViews, and can be disabled when creating
+	 * VkImageViews that don't need it, and compiling pipelines that use those VkImageViews.
+	 *
+	 * Existing pipelines are not automatically re-compiled when this parameter is changed.
+	 *
+	 * An error is logged and returned during VkImageView creation if that VkImageView
+	 * requires full image view swizzling and this feature is not enabled. An error is
+	 * also logged when a pipeline that was not compiled with full image view swizzling
+	 * is presented with a VkImageView that is expecting it.
+	 *
+	 * An error is also retuned and logged when a VkPhysicalDeviceImageFormatInfo2KHR is passed
+	 * in a call to vkGetPhysicalDeviceImageFormatProperties2KHR() to query for an VkImageView
+	 * format that will require full swizzling to be enabled, and this feature is not enabled.
+	 *
+	 * If this parameter is disabled, the following limited set of VkImageView swizzles are
+	 * supported by MoltenVK, via automatic format substitution:
+	 *
+	 * Texture format			       Swizzle
+	 * --------------                  -------
+	 * VK_FORMAT_R8_UNORM              ZERO, ANY, ANY, RED
+	 * VK_FORMAT_A8_UNORM              ALPHA, ANY, ANY, ZERO
+	 * VK_FORMAT_R8G8B8A8_UNORM        BLUE, GREEN, RED, ALPHA
+	 * VK_FORMAT_R8G8B8A8_SRGB         BLUE, GREEN, RED, ALPHA
+	 * VK_FORMAT_B8G8R8A8_UNORM        BLUE, GREEN, RED, ALPHA
+	 * VK_FORMAT_B8G8R8A8_SRGB         BLUE, GREEN, RED, ALPHA
+	 * VK_FORMAT_D32_SFLOAT_S8_UINT    RED, ANY, ANY, ANY (stencil only)
+	 * VK_FORMAT_D24_UNORM_S8_UINT     RED, ANY, ANY, ANY (stencil only)
+	 *
+	 * The initial value or this parameter is set by the
+	 * MVK_CONFIG_FULL_IMAGE_VIEW_SWIZZLE
+	 * runtime environment variable or MoltenVK compile-time build setting.
+	 * If neither is set, the value of this parameter defaults to false.
+	 */
+	VkBool32 fullImageViewSwizzle;
+
+	/**
+	 * The index of the queue family whose presentation submissions will
+	 * be used as the default GPU Capture Scope during debugging in Xcode.
+	 *
+	 * The value of this parameter must be changed before creating a VkDevice,
+	 * for the change to take effect.
+	 *
+	 * The initial value or this parameter is set by the
+	 * MVK_CONFIG_DEFAULT_GPU_CAPTURE_SCOPE_QUEUE_FAMILY_INDEX
+	 * runtime environment variable or MoltenVK compile-time build setting.
+	 * If neither is set, the value of this parameter defaults to zero (the first queue family).
+	 */
+	uint32_t defaultGPUCaptureScopeQueueFamilyIndex;
+
+	/**
+	 * The index of the queue, within the queue family identified by the
+	 * defaultGPUCaptureScopeQueueFamilyIndex parameter, whose presentation submissions
+	 * will be used as the default GPU Capture Scope during debugging in Xcode.
+	 *
+	 * The value of this parameter must be changed before creating a VkDevice,
+	 * for the change to take effect.
+	 *
+	 * The initial value or this parameter is set by the
+	 * MVK_CONFIG_DEFAULT_GPU_CAPTURE_SCOPE_QUEUE_INDEX
+	 * runtime environment variable or MoltenVK compile-time build setting.
+	 * If neither is set, the value of this parameter defaults to zero (the first queue).
+	 */
+	uint32_t defaultGPUCaptureScopeQueueIndex;
+
+	/**
+	 * Corresponds to the fastMathEnabled property of MTLCompileOptions.
+	 * Setting it may cause the Metal Compiler to optimize floating point operations
+	 * in ways that may violate the IEEE 754 standard.
+	 *
+	 * Must be changed before creating a VkDevice, for the change to take effect.
+	 *
+	 * The initial value or this parameter is set by the
+	 * MVK_CONFIG_FAST_MATH_ENABLED
+	 * runtime environment variable or MoltenVK compile-time build setting.
+	 * If neither is set, the value of this parameter defaults to true.
+	 */
+	VkBool32 fastMathEnabled;
+
+	/**
+	 * Controls the level of logging performned by MoltenVK using the following numeric values:
+	 *   0: No logging.
+	 *   1: Log errors only.
+	 *   2: Log errors and informational messages.
+	 *
+	 * The value of this parameter may be changed at any time during application runtime,
+	 * and the changed value will immediately effect subsequent MoltenVK behaviour.
+	 *
+	 * The initial value or this parameter is set by the
+	 * MVK_CONFIG_LOG_LEVEL
+	 * runtime environment variable or MoltenVK compile-time build setting.
+	 * If neither is set, errors and informational messages are logged.
+	 */
+	uint32_t logLevel;
+
+	/**
+	 * Causes MoltenVK to log the name of each Vulkan call made by the application,
+	 * along with the Mach thread ID, global system thread ID, and thread name.
+	 * The logging format options can be controlled as follows:
+	 *   0: No Vulkan call logging.
+	 *   1: Log the name of each Vulkan call when the call is entered.
+	 *   2: Log the name of each Vulkan call when the call is entered and exited. This
+	 *      effectively brackets any other logging activity within the scope of the Vulkan call.
+	 *   3: Same as option 2, plus logs the time spent inside the Vulkan function.
+	 * If none of these is set, no Vulkan call logging will occur.
+	 *
+	 * The value of this parameter may be changed at any time during application runtime,
+	 * and the changed value will immediately effect subsequent MoltenVK behaviour.
+	 *
+	 * The initial value or this parameter is set by the
+	 * MVK_CONFIG_TRACE_VULKAN_CALLS
+	 * runtime environment variable or MoltenVK compile-time build setting.
+	 * If neither is set, no Vulkan call logging will occur.
+	 */
+	uint32_t traceVulkanCalls;
+
+	/**
+	 * Force MoltenVK to use a low-power GPU, if one is availble on the device.
+	 *
+	 * The value of this parameter must be changed before creating a VkInstance,
+	 * for the change to take effect.
+	 *
+	 * The initial value or this parameter is set by the
+	 * MVK_CONFIG_FORCE_LOW_POWER_GPU
+	 * runtime environment variable or MoltenVK compile-time build setting.
+	 * If neither is set, this setting is disabled by default, allowing both
+	 * low-power and high-power GPU's to be used.
+	 */
+	VkBool32 forceLowPowerGPU;
+
+	/**
+	 * Use MTLFence, if it is available on the device, for VkSemaphore synchronization behaviour.
+	 *
+	 * This parameter interacts with semaphoreUseMTLEvent. If both are enabled, semaphoreUseMTLFence
+	 * takes priority and MTLFence will be used if it is available, otherwise MTLEvent will be used
+	 * if it is available. If neither semaphoreUseMTLFence or semaphoreUseMTLEvent are enabled, or
+	 * if neither MTLFence or MTLEvent are available, CPU-based synchoronization will be used.
+	 *
+	 * In the special case of VK_SEMAPHORE_TYPE_TIMELINE semaphores, MoltenVK will always
+	 * use MTLSharedEvent if it is available on the platform, regardless of the values of
+	 * MVK_ALLOW_METAL_FENCES or MVK_ALLOW_METAL_EVENTS.
+	 *
+	 * The value of this parameter must be changed before creating a VkDevice,
+	 * for the change to take effect.
+	 *
+	 * The initial value or this parameter is set by the
+	 * MVK_ALLOW_METAL_FENCES
+	 * runtime environment variable or MoltenVK compile-time build setting.
+	 * If neither is set, this setting is enabled by default, and VkSemaphore will use MTLFence,
+	 * if it is available.
+	 */
+	VkBool32 semaphoreUseMTLFence;
+
+	/**
+	 * Use MTLEvent, if it is available on the device, for VkSemaphore synchronization behaviour.
+	 *
+	 * This parameter interacts with semaphoreUseMTLFence. If both are enabled, semaphoreUseMTLFence
+	 * takes priority and MTLFence will be used if it is available, otherwise MTLEvent will be used
+	 * if it is available. If neither semaphoreUseMTLFence or semaphoreUseMTLEvent are enabled, or
+	 * if neither MTLFence or MTLEvent are available, CPU-based synchoronization will be used.
+	 *
+	 * In the special case of VK_SEMAPHORE_TYPE_TIMELINE semaphores, MoltenVK will always
+	 * use MTLSharedEvent if it is available on the platform, regardless of the values of
+	 * MVK_ALLOW_METAL_FENCES or MVK_ALLOW_METAL_EVENTS.
+	 *
+	 * The value of this parameter must be changed before creating a VkDevice,
+	 * for the change to take effect.
+	 *
+	 * The initial value or this parameter is set by the
+	 * MVK_ALLOW_METAL_EVENTS
+	 * runtime environment variable or MoltenVK compile-time build setting.
+	 * If neither is set, this setting is enabled by default, and VkSemaphore will use MTLEvent,
+	 * if it is available, unless if MTLFence is available and semaphoreUseMTLFence is enabled.
+	 */
+	VkBool32 semaphoreUseMTLEvent;
+
+	/**
+	 * Controls whether Metal should run an automatic GPU capture without the user having to
+	 * trigger it manually via the Xcode user interface, and controls the scope under which
+	 * that GPU capture will occur. This is useful when trying to capture a one-shot GPU trace,
+	 * such as when running a Vulkan CTS test case. For the automatic GPU capture to occur,
+	 * the Xcode scheme under which the app is run must have the Metal GPU capture option
+	 * enabled. MVK_CONFIG_AUTO_GPU_CAPTURE_SCOPE should not be set to manually trigger a
+	 * GPU capture via the Xcode user interface.
+	 *
+	 * To automatically trigger a GPU capture, set this value as follows:
+	 *   0: No automatic GPU capture.
+	 *   1: Capture all GPU commands issued during the lifetime of the VkDevice.
+	 *   2: Capture all GPU commands issued during the first rendered frame.
+	 *
+	 * The value of this parameter must be changed before creating a VkDevice,
+	 * for the change to take effect.
+	 *
+	 * The initial value or this parameter is set by the
+	 * MVK_CONFIG_AUTO_GPU_CAPTURE_SCOPE
+	 * runtime environment variable or MoltenVK compile-time build setting.
+	 * If neither is set, no automatic GPU capture will occur.
+	 */
+	uint32_t autoGPUCaptureScope;
+
+	/**
+	 * The path to a file where the automatic GPU capture should be saved, if autoGPUCaptureScope
+	 * is enabled. In this case, the Xcode scheme need not have Metal GPU capture enabled, and in
+	 * fact the app need not be run under Xcode's control at all. This is useful in case the app
+	 * cannot be run under Xcode's control. A path starting with '~' can be used to place it in a
+	 * user's home directory, as in the shell. This feature requires Metal 3.0 (macOS 10.15, iOS 13).
+	 *
+	 * If this parameter is NULL or an empty string, and autoGPUCaptureScope is enabled, automatic
+	 * GPU capture will be handled by the Xcode user interface.
+	 *
+	 * The value of this parameter must be changed before creating a VkDevice,
+	 * for the change to take effect.
+	 *
+	 * The initial value or this parameter is set by the
+	 * MVK_CONFIG_AUTO_GPU_CAPTURE_OUTPUT_FILE
+	 * runtime environment variable or MoltenVK compile-time build setting.
+	 * If neither is set, automatic GPU capture will be handled by the Xcode user interface.
+	 */
+	char* autoGPUCaptureOutputFilepath;
+
+	/**
+	 * Controls whether MoltenVK should use a Metal 2D texture with a height of 1 for a
+	 * Vulkan 1D image, or use a native Metal 1D texture. Metal imposes significant restrictions
+	 * on native 1D textures, including not being renderable, clearable, or permitting mipmaps.
+	 * Using a Metal 2D texture allows Vulkan 1D textures to support this additional functionality.
+	 *
+	 * The value of this parameter should only be changed before creating the VkInstance.
+	 *
+	 * The initial value or this parameter is set by the
+	 * MVK_CONFIG_TEXTURE_1D_AS_2D
+	 * runtime environment variable or MoltenVK compile-time build setting.
+	 * If neither is set, this setting is enabled by default, and MoltenVK will
+	 * use a Metal 2D texture for each Vulkan 1D image.
+	 */
+	VkBool32 texture1DAs2D;
+
+	/**
+	 * Controls whether MoltenVK should preallocate memory in each VkDescriptorPool
+	 * ccording to the values of the VkDescriptorPoolSize parameters. Doing so may improve
+	 * descriptor set allocation performance at a cost of preallocated application memory,
+	 * and possible descreased performance when creating and reseting the VkDescriptorPool.
+	 * If this setting is disabled, the descriptors required for a descriptor set will
+	 * be dynamically allocated in application memory when the descriptor set itself is allocated.
+	 *
+	 * The value of this parameter may be changed at any time during application runtime,
+	 * and the changed value will immediately effect behavior of VkDescriptorPools created
+	 * after the setting is changed.
+	 *
+	 * The initial value or this parameter is set by the
+	 * MVK_CONFIG_PREALLOCATE_DESCRIPTORS
+	 * runtime environment variable or MoltenVK compile-time build setting.
+	 * If neither is set, this setting is disabled by default, and MoltenVK will
+	 * dynamically allocate descriptors when the containing descriptor set is allocated.
+	 */
+	VkBool32 preallocateDescriptors;
+
+	/**
+	 * Controls whether MoltenVK should use pools to manage memory used when adding commands
+	 * to command buffers. If this setting is enabled, MoltenVK will use a pool to hold command
+	 * resources for reuse during command execution. If this setting is disabled, command memory
+	 * is allocated and destroyed each time a command is executed. This is a classic time-space
+	 * trade off. When command pooling is active, the memory in the pool can be cleared via a
+	 * call to the vkTrimCommandPoolKHR() command.
+	 *
+	 * The value of this parameter may be changed at any time during application runtime,
+	 * and the changed value will immediately effect behavior of VkCommandPools created
+	 * after the setting is changed.
+	 *
+	 * The initial value or this parameter is set by the
+	 * MVK_CONFIG_USE_COMMAND_POOLING
+	 * runtime environment variable or MoltenVK compile-time build setting.
+	 * If neither is set, this setting is enabled by default, and MoltenVK will pool command memory.
+	 */
+	VkBool32 useCommandPooling;
+
+	/**
+	 * Controls whether MoltenVK should use MTLHeaps for allocating textures and buffers
+	 * from device memory. If this setting is enabled, and placement MTLHeaps are
+	 * available on the platform, MoltenVK will allocate a placement MTLHeap for each VkDeviceMemory
+	 * instance, and allocate textures and buffers from that placement heap. If this environment
+	 * variable is disabled, MoltenVK will allocate textures and buffers from general device memory.
+	 *
+	 * Apple recommends that MTLHeaps should only be used for specific requirements such as aliasing
+	 * or hazard tracking, and MoltenVK testing has shown that allocating multiple textures of
+	 * different types or usages from one MTLHeap can occassionally cause corruption issues under
+	 * certain circumstances.
+	 *
+	 * The value of this parameter must be changed before creating a VkInstance,
+	 * for the change to take effect.
+	 *
+	 * The initial value or this parameter is set by the
+	 * MVK_CONFIG_USE_MTLHEAP
+	 * runtime environment variable or MoltenVK compile-time build setting.
+	 * If neither is set, this setting is disabled by default, and MoltenVK
+	 * will allocate texures and buffers from general device memory.
+	 */
+	VkBool32 useMTLHeap;
+
+	/**
+	 * Controls whether MoltenVK should log the performance of individual activities as they happen.
+	 * If this setting is enabled, activity performance will be logged when each activity happens.
+	 * If this setting is disabled, activity performance will be logged when frame peformance is
+	 * logged as determined by the performanceLoggingFrameCount value.
+	 *
+	 * The value of this parameter must be changed before creating a VkDevice,
+	 * for the change to take effect.
+	 *
+	 * The initial value or this parameter is set by the
+	 * MVK_CONFIG_PERFORMANCE_LOGGING_INLINE
+	 * runtime environment variable or MoltenVK compile-time build setting.
+	 * If neither is set, this setting is disabled by default, and activity
+	 * performance will be logged only when frame activity is logged.
+	 */
+	VkBool32 logActivityPerformanceInline;
+
+} MVKConfiguration;
+
+/**
+ * Features provided by the current implementation of Metal on the current device. You can
+ * retrieve a copy of this structure using the vkGetPhysicalDeviceMetalFeaturesMVK() function.
+ *
+ * This structure may be extended as new features are added to MoltenVK. If you are linking to
+ * an implementation of MoltenVK that was compiled from a different VK_MVK_MOLTENVK_SPEC_VERSION
+ * than your app was, the size of this structure in your app may be larger or smaller than the
+ * struct in MoltenVK. See the description of the vkGetPhysicalDeviceMetalFeaturesMVK() function
+ * for information about how to handle this.
+ *
+ * TO SUPPORT DYNAMIC LINKING TO THIS STRUCTURE AS DESCRIBED ABOVE, THIS STRUCTURE SHOULD NOT
+ * BE CHANGED EXCEPT TO ADD ADDITIONAL MEMBERS ON THE END. EXISTING MEMBERS, AND THEIR ORDER,
+ * SHOULD NOT BE CHANGED.
+ */
+typedef struct {
+    uint32_t mslVersion;                        /**< The version of the Metal Shading Language available on this device. The format of the integer is MMmmpp, with two decimal digts each for Major, minor, and patch version values (eg. MSL 1.2 would appear as 010200). */
+	VkBool32 indirectDrawing;                   /**< If true, draw calls support parameters held in a GPU buffer. */
+	VkBool32 baseVertexInstanceDrawing;         /**< If true, draw calls support specifiying the base vertex and instance. */
+    uint32_t dynamicMTLBufferSize;              /**< If greater than zero, dynamic MTLBuffers for setting vertex, fragment, and compute bytes are supported, and their content must be below this value. */
+    VkBool32 shaderSpecialization;              /**< If true, shader specialization (aka Metal function constants) is supported. */
+    VkBool32 ioSurfaces;                        /**< If true, VkImages can be underlaid by IOSurfaces via the vkUseIOSurfaceMVK() function, to support inter-process image transfers. */
+    VkBool32 texelBuffers;                      /**< If true, texel buffers are supported, allowing the contents of a buffer to be interpreted as an image via a VkBufferView. */
+	VkBool32 layeredRendering;                  /**< If true, layered rendering to multiple cube or texture array layers is supported. */
+	VkBool32 presentModeImmediate;              /**< If true, immediate surface present mode (VK_PRESENT_MODE_IMMEDIATE_KHR), allowing a swapchain image to be presented immediately, without waiting for the vertical sync period of the display, is supported. */
+	VkBool32 stencilViews;                      /**< If true, stencil aspect views are supported through the MTLPixelFormatX24_Stencil8 and MTLPixelFormatX32_Stencil8 formats. */
+	VkBool32 multisampleArrayTextures;          /**< If true, MTLTextureType2DMultisampleArray is supported. */
+	VkBool32 samplerClampToBorder;              /**< If true, the border color set when creating a sampler will be respected. */
+	uint32_t maxTextureDimension; 	     	  	/**< The maximum size of each texture dimension (width, height, or depth). */
+	uint32_t maxPerStageBufferCount;            /**< The total number of per-stage Metal buffers available for shader uniform content and attributes. */
+    uint32_t maxPerStageTextureCount;           /**< The total number of per-stage Metal textures available for shader uniform content. */
+    uint32_t maxPerStageSamplerCount;           /**< The total number of per-stage Metal samplers available for shader uniform content. */
+    VkDeviceSize maxMTLBufferSize;              /**< The max size of a MTLBuffer (in bytes). */
+    VkDeviceSize mtlBufferAlignment;            /**< The alignment used when allocating memory for MTLBuffers. Must be PoT. */
+    VkDeviceSize maxQueryBufferSize;            /**< The maximum size of an occlusion query buffer (in bytes). */
+	VkDeviceSize mtlCopyBufferAlignment;        /**< The alignment required during buffer copy operations (in bytes). */
+    VkSampleCountFlags supportedSampleCounts;   /**< A bitmask identifying the sample counts supported by the device. */
+	uint32_t minSwapchainImageCount;	 	  	/**< The minimum number of swapchain images that can be supported by a surface. */
+	uint32_t maxSwapchainImageCount;	 	  	/**< The maximum number of swapchain images that can be supported by a surface. */
+	VkBool32 combinedStoreResolveAction;		/**< If true, the device supports VK_ATTACHMENT_STORE_OP_STORE with a simultaneous resolve attachment. */
+	VkBool32 arrayOfTextures;			 	  	/**< If true, arrays of textures is supported. */
+	VkBool32 arrayOfSamplers;			 	  	/**< If true, arrays of texture samplers is supported. */
+	MTLLanguageVersion mslVersionEnum;			/**< The version of the Metal Shading Language available on this device, as a Metal enumeration. */
+	VkBool32 depthSampleCompare;				/**< If true, depth texture samplers support the comparison of the pixel value against a reference value. */
+	VkBool32 events;							/**< If true, Metal synchronization events (MTLEvent) are supported. */
+	VkBool32 memoryBarriers;					/**< If true, full memory barriers within Metal render passes are supported. */
+	VkBool32 multisampleLayeredRendering;       /**< If true, layered rendering to multiple multi-sampled cube or texture array layers is supported. */
+	VkBool32 stencilFeedback;					/**< If true, fragment shaders that write to [[stencil]] outputs are supported. */
+	VkBool32 textureBuffers;					/**< If true, textures of type MTLTextureTypeBuffer are supported. */
+	VkBool32 postDepthCoverage;					/**< If true, coverage masks in fragment shaders post-depth-test are supported. */
+	VkBool32 fences;							/**< If true, Metal synchronization fences (MTLFence) are supported. */
+	VkBool32 rasterOrderGroups;					/**< If true, Raster order groups in fragment shaders are supported. */
+	VkBool32 native3DCompressedTextures;		/**< If true, 3D compressed images are supported natively, without manual decompression. */
+	VkBool32 nativeTextureSwizzle;				/**< If true, component swizzle is supported natively, without manual swizzling in shaders. */
+	VkBool32 placementHeaps;					/**< If true, MTLHeap objects support placement of resources. */
+	VkDeviceSize pushConstantSizeAlignment;		/**< The alignment used internally when allocating memory for push constants. Must be PoT. */
+	uint32_t maxTextureLayers;					/**< The maximum number of layers in an array texture. */
+    uint32_t maxSubgroupSize;			        /**< The maximum number of threads in a SIMD-group. */
+	VkDeviceSize vertexStrideAlignment;         /**< The alignment used for the stride of vertex attribute bindings. */
+	VkBool32 indirectTessellationDrawing;		/**< If true, tessellation draw calls support parameters held in a GPU buffer. */
+	VkBool32 nonUniformThreadgroups;			/**< If true, the device supports arbitrary-sized grids in compute workloads. */
+	VkBool32 renderWithoutAttachments;          /**< If true, we don't have to create a dummy attachment for a render pass if there isn't one. */
+	VkBool32 deferredStoreActions;				/**< If true, render pass store actions can be specified after the render encoder is created. */
+	VkBool32 sharedLinearTextures;				/**< If true, linear textures and texture buffers can be created from buffers in Shared storage. */
+	VkBool32 depthResolve;						/**< If true, resolving depth textures with filters other than Sample0 is supported. */
+	VkBool32 stencilResolve;					/**< If true, resolving stencil textures with filters other than Sample0 is supported. */
+	uint32_t maxPerStageDynamicMTLBufferCount;	/**< The maximum number of inline buffers that can be set on a command buffer. */
+	uint32_t maxPerStageStorageTextureCount;    /**< The total number of per-stage Metal textures with read-write access available for writing to from a shader. */
+	VkBool32 astcHDRTextures;					/**< If true, ASTC HDR pixel formats are supported. */
+	VkBool32 renderLinearTextures;				/**< If true, linear textures are renderable. */
+	VkBool32 pullModelInterpolation;			/**< If true, explicit interpolation functions are supported. */
+	VkBool32 samplerMirrorClampToEdge;			/**< If true, the mirrored clamp to edge address mode is supported in samplers. */
+	VkBool32 quadPermute;						/**< If true, quadgroup permutation functions (vote, ballot, shuffle) are supported in shaders. */
+	VkBool32 simdPermute;						/**< If true, SIMD-group permutation functions (vote, ballot, shuffle) are supported in shaders. */
+	VkBool32 simdReduction;						/**< If true, SIMD-group reduction functions (arithmetic) are supported in shaders. */
+    uint32_t minSubgroupSize;			        /**< The minimum number of threads in a SIMD-group. */
+    VkBool32 textureBarriers;                   /**< If true, texture barriers are supported within Metal render passes. */
+    VkBool32 tileBasedDeferredRendering;        /**< If true, this device uses tile-based deferred rendering. */
+} MVKPhysicalDeviceMetalFeatures;
+
+/** MoltenVK performance of a particular type of activity. */
+typedef struct {
+    uint32_t count;             /**< The number of activities of this type. */
+	double latestDuration;      /**< The latest (most recent) duration of the activity, in milliseconds. */
+    double averageDuration;     /**< The average duration of the activity, in milliseconds. */
+    double minimumDuration;     /**< The minimum duration of the activity, in milliseconds. */
+    double maximumDuration;     /**< The maximum duration of the activity, in milliseconds. */
+} MVKPerformanceTracker;
+
+/** MoltenVK performance of shader compilation activities. */
+typedef struct {
+	MVKPerformanceTracker hashShaderCode;				/** Create a hash from the incoming shader code. */
+    MVKPerformanceTracker spirvToMSL;					/** Convert SPIR-V to MSL source code. */
+    MVKPerformanceTracker mslCompile;					/** Compile MSL source code into a MTLLibrary. */
+    MVKPerformanceTracker mslLoad;						/** Load pre-compiled MSL code into a MTLLibrary. */
+	MVKPerformanceTracker shaderLibraryFromCache;		/** Retrieve a shader library from the cache, lazily creating it if needed. */
+    MVKPerformanceTracker functionRetrieval;			/** Retrieve a MTLFunction from a MTLLibrary. */
+    MVKPerformanceTracker functionSpecialization;		/** Specialize a retrieved MTLFunction. */
+    MVKPerformanceTracker pipelineCompile;				/** Compile MTLFunctions into a pipeline. */
+	MVKPerformanceTracker glslToSPRIV;					/** Convert GLSL to SPIR-V code. */
+} MVKShaderCompilationPerformance;
+
+/** MoltenVK performance of pipeline cache activities. */
+typedef struct {
+	MVKPerformanceTracker sizePipelineCache;			/** Calculate the size of cache data required to write MSL to pipeline cache data stream. */
+	MVKPerformanceTracker writePipelineCache;			/** Write MSL to pipeline cache data stream. */
+	MVKPerformanceTracker readPipelineCache;			/** Read MSL from pipeline cache data stream. */
+} MVKPipelineCachePerformance;
+
+/** MoltenVK performance of queue activities. */
+typedef struct {
+	MVKPerformanceTracker mtlQueueAccess;               /** Create an MTLCommandQueue or access an existing cached instance. */
+	MVKPerformanceTracker mtlCommandBufferCompletion;   /** Completion of a MTLCommandBuffer on the GPU, from commit to completion callback. */
+	MVKPerformanceTracker nextCAMetalDrawable;			/** Retrieve next CAMetalDrawable from CAMetalLayer during presentation. */
+	MVKPerformanceTracker frameInterval;				/** Frame presentation interval (1000/FPS). */
+} MVKQueuePerformance;
+
+/**
+ * MoltenVK performance. You can retrieve a copy of this structure using the vkGetPerformanceStatisticsMVK() function.
+ *
+ * This structure may be extended as new features are added to MoltenVK. If you are linking to
+ * an implementation of MoltenVK that was compiled from a different VK_MVK_MOLTENVK_SPEC_VERSION
+ * than your app was, the size of this structure in your app may be larger or smaller than the
+ * struct in MoltenVK. See the description of the vkGetPerformanceStatisticsMVK() function for
+ * information about how to handle this.
+ *
+ * TO SUPPORT DYNAMIC LINKING TO THIS STRUCTURE AS DESCRIBED ABOVE, THIS STRUCTURE SHOULD NOT
+ * BE CHANGED EXCEPT TO ADD ADDITIONAL MEMBERS ON THE END. EXISTING MEMBERS, AND THEIR ORDER,
+ * SHOULD NOT BE CHANGED.
+ */
+typedef struct {
+	MVKShaderCompilationPerformance shaderCompilation;	/** Shader compilations activities. */
+	MVKPipelineCachePerformance pipelineCache;			/** Pipeline cache activities. */
+	MVKQueuePerformance queue;          				/** Queue activities. */
+} MVKPerformanceStatistics;
+
+
+#pragma mark -
+#pragma mark Function types
+
+typedef VkResult (VKAPI_PTR *PFN_vkGetMoltenVKConfigurationMVK)(VkInstance ignored, MVKConfiguration* pConfiguration, size_t* pConfigurationSize);
+typedef VkResult (VKAPI_PTR *PFN_vkSetMoltenVKConfigurationMVK)(VkInstance ignored, MVKConfiguration* pConfiguration, size_t* pConfigurationSize);
+typedef VkResult (VKAPI_PTR *PFN_vkGetPhysicalDeviceMetalFeaturesMVK)(VkPhysicalDevice physicalDevice, MVKPhysicalDeviceMetalFeatures* pMetalFeatures, size_t* pMetalFeaturesSize);
+typedef VkResult (VKAPI_PTR *PFN_vkGetPerformanceStatisticsMVK)(VkDevice device, MVKPerformanceStatistics* pPerf, size_t* pPerfSize);
+typedef void (VKAPI_PTR *PFN_vkGetVersionStringsMVK)(char* pMoltenVersionStringBuffer, uint32_t moltenVersionStringBufferLength, char* pVulkanVersionStringBuffer, uint32_t vulkanVersionStringBufferLength);
+
+#ifdef __OBJC__
+typedef void (VKAPI_PTR *PFN_vkGetMTLDeviceMVK)(VkPhysicalDevice physicalDevice, id<MTLDevice>* pMTLDevice);
+typedef VkResult (VKAPI_PTR *PFN_vkSetMTLTextureMVK)(VkImage image, id<MTLTexture> mtlTexture);
+typedef void (VKAPI_PTR *PFN_vkGetMTLTextureMVK)(VkImage image, id<MTLTexture>* pMTLTexture);
+typedef void (VKAPI_PTR *PFN_vkGetMTLBufferMVK)(VkBuffer buffer, id<MTLBuffer>* pMTLBuffer);
+typedef VkResult (VKAPI_PTR *PFN_vkUseIOSurfaceMVK)(VkImage image, IOSurfaceRef ioSurface);
+typedef void (VKAPI_PTR *PFN_vkGetIOSurfaceMVK)(VkImage image, IOSurfaceRef* pIOSurface);
+#endif // __OBJC__
+
+
+#pragma mark -
+#pragma mark Function prototypes
+
+#ifndef VK_NO_PROTOTYPES
+
+/** 
+ * Populates the pConfiguration structure with the current MoltenVK configuration settings.
+ *
+ * To change a specific configuration value, call vkGetMoltenVKConfigurationMVK() to retrieve
+ * the current configuration, make changes, and call  vkSetMoltenVKConfigurationMVK() to
+ * update all of the values.
+ *
+ * The VkInstance object you provide here is ignored, and a VK_NULL_HANDLE value can be provided.
+ * This function can be called before the VkInstance has been created. It is safe to call this function
+ * with a VkInstance retrieved from a different layer in the Vulkan SDK Loader and Layers framework.
+ *
+ * To be active, some configuration settings must be set before a VkInstance or VkDevice
+ * is created. See the description of the MVKConfiguration members for more information.
+ *
+ * If you are linking to an implementation of MoltenVK that was compiled from a different
+ * VK_MVK_MOLTENVK_SPEC_VERSION than your app was, the size of the MVKConfiguration structure
+ * in your app may be larger or smaller than the same struct as expected by MoltenVK.
+ *
+ * When calling this function, set the value of *pConfigurationSize to sizeof(MVKConfiguration),
+ * to tell MoltenVK the limit of the size of your MVKConfiguration structure. Upon return from
+ * this function, the value of *pConfigurationSize will hold the actual number of bytes copied
+ * into your passed MVKConfiguration structure, which will be the smaller of what your app
+ * thinks is the size of MVKConfiguration, and what MoltenVK thinks it is. This represents the
+ * safe access area within the structure for both MoltenVK and your app.
+ *
+ * If the size that MoltenVK expects for MVKConfiguration is different than the value passed in
+ * *pConfigurationSize, this function will return VK_INCOMPLETE, otherwise it will return VK_SUCCESS.
+ *
+ * Although it is not necessary, you can use this function to determine in advance the value
+ * that MoltenVK expects the size of MVKConfiguration to be by setting the value of pConfiguration
+ * to NULL. In that case, this function will set *pConfigurationSize to the size that MoltenVK
+ * expects MVKConfiguration to be.
+ */
+VKAPI_ATTR VkResult VKAPI_CALL vkGetMoltenVKConfigurationMVK(
+	VkInstance                                  ignored,
+	MVKConfiguration*                           pConfiguration,
+	size_t*                                     pConfigurationSize);
+
+/** 
+ * Sets the MoltenVK configuration settings to those found in the pConfiguration structure.
+ *
+ * To change a specific configuration value, call vkGetMoltenVKConfigurationMVK()
+ * to retrieve the current configuration, make changes, and call
+ * vkSetMoltenVKConfigurationMVK() to update all of the values.
+ *
+ * The VkInstance object you provide here is ignored, and a VK_NULL_HANDLE value can be provided.
+ * This function can be called before the VkInstance has been created. It is safe to call this function
+ * with a VkInstance retrieved from a different layer in the Vulkan SDK Loader and Layers framework.
+ *
+ * To be active, some configuration settings must be set before a VkInstance or VkDevice
+ * is created. See the description of the MVKConfiguration members for more information.
+ *
+ * If you are linking to an implementation of MoltenVK that was compiled from a different
+ * VK_MVK_MOLTENVK_SPEC_VERSION than your app was, the size of the MVKConfiguration structure
+ * in your app may be larger or smaller than the same struct as expected by MoltenVK.
+ *
+ * When calling this function, set the value of *pConfigurationSize to sizeof(MVKConfiguration),
+ * to tell MoltenVK the limit of the size of your MVKConfiguration structure. Upon return from
+ * this function, the value of *pConfigurationSize will hold the actual number of bytes copied
+ * out of your passed MVKConfiguration structure, which will be the smaller of what your app
+ * thinks is the size of MVKConfiguration, and what MoltenVK thinks it is. This represents the
+ * safe access area within the structure for both MoltenVK and your app.
+ *
+ * If the size that MoltenVK expects for MVKConfiguration is different than the value passed in
+ * *pConfigurationSize, this function will return VK_INCOMPLETE, otherwise it will return VK_SUCCESS.
+ *
+ * Although it is not necessary, you can use this function to determine in advance the value
+ * that MoltenVK expects the size of MVKConfiguration to be by setting the value of pConfiguration
+ * to NULL. In that case, this function will set *pConfigurationSize to the size that MoltenVK
+ * expects MVKConfiguration to be.
+ */
+VKAPI_ATTR VkResult VKAPI_CALL vkSetMoltenVKConfigurationMVK(
+	VkInstance                                  ignored,
+	const MVKConfiguration*                     pConfiguration,
+	size_t*                                     pConfigurationSize);
+
+/** 
+ * Populates the pMetalFeatures structure with the Metal-specific features
+ * supported by the specified physical device. 
+ *
+ * If you are linking to an implementation of MoltenVK that was compiled from a different
+ * VK_MVK_MOLTENVK_SPEC_VERSION than your app was, the size of the MVKPhysicalDeviceMetalFeatures
+ * structure in your app may be larger or smaller than the same struct as expected by MoltenVK.
+ *
+ * When calling this function, set the value of *pMetalFeaturesSize to sizeof(MVKPhysicalDeviceMetalFeatures),
+ * to tell MoltenVK the limit of the size of your MVKPhysicalDeviceMetalFeatures structure. Upon return from
+ * this function, the value of *pMetalFeaturesSize will hold the actual number of bytes copied into your
+ * passed MVKPhysicalDeviceMetalFeatures structure, which will be the smaller of what your app thinks is the
+ * size of MVKPhysicalDeviceMetalFeatures, and what MoltenVK thinks it is. This represents the safe access
+ * area within the structure for both MoltenVK and your app.
+ *
+ * If the size that MoltenVK expects for MVKPhysicalDeviceMetalFeatures is different than the value passed in
+ * *pMetalFeaturesSize, this function will return VK_INCOMPLETE, otherwise it will return VK_SUCCESS.
+ *
+ * Although it is not necessary, you can use this function to determine in advance the value that MoltenVK
+ * expects the size of MVKPhysicalDeviceMetalFeatures to be by setting the value of pMetalFeatures to NULL.
+ * In that case, this function will set *pMetalFeaturesSize to the size that MoltenVK expects
+ * MVKPhysicalDeviceMetalFeatures to be.
+ *
+ * This function is not supported by the Vulkan SDK Loader and Layers framework.
+ * The VkPhysicalDevice object you provide here must have been retrieved directly from
+ * MoltenVK, and not through the Vulkan SDK Loader and Layers framework. Opaque Vulkan
+ * objects are often changed by layers, and passing them from one layer to another,
+ * or from a layer directly to MoltenVK, will result in undefined behaviour.
+ */
+VKAPI_ATTR VkResult VKAPI_CALL vkGetPhysicalDeviceMetalFeaturesMVK(
+	VkPhysicalDevice                            physicalDevice,
+	MVKPhysicalDeviceMetalFeatures*             pMetalFeatures,
+	size_t*                                     pMetalFeaturesSize);
+
+/**
+ * Populates the pPerf structure with the current performance statistics for the device.
+ *
+ * If you are linking to an implementation of MoltenVK that was compiled from a different
+ * VK_MVK_MOLTENVK_SPEC_VERSION than your app was, the size of the MVKPerformanceStatistics
+ * structure in your app may be larger or smaller than the same struct as expected by MoltenVK.
+ *
+ * When calling this function, set the value of *pPerfSize to sizeof(MVKPerformanceStatistics),
+ * to tell MoltenVK the limit of the size of your MVKPerformanceStatistics structure. Upon return
+ * from this function, the value of *pPerfSize will hold the actual number of bytes copied into
+ * your passed MVKPerformanceStatistics structure, which will be the smaller of what your app
+ * thinks is the size of MVKPerformanceStatistics, and what MoltenVK thinks it is. This
+ * represents the safe access area within the structure for both MoltenVK and your app.
+ *
+ * If the size that MoltenVK expects for MVKPerformanceStatistics is different than the value passed
+ * in *pPerfSize, this function will return VK_INCOMPLETE, otherwise it will return VK_SUCCESS.
+ *
+ * Although it is not necessary, you can use this function to determine in advance the value
+ * that MoltenVK expects the size of MVKPerformanceStatistics to be by setting the value of
+ * pPerf to NULL. In that case, this function will set *pPerfSize to the size that MoltenVK
+ * expects MVKPerformanceStatistics to be.
+ *
+ * This function is not supported by the Vulkan SDK Loader and Layers framework.
+ * The VkDevice object you provide here must have been retrieved directly from
+ * MoltenVK, and not through the Vulkan SDK Loader and Layers framework. Opaque Vulkan
+ * objects are often changed by layers, and passing them from one layer to another,
+ * or from a layer directly to MoltenVK, will result in undefined behaviour.
+ */
+VKAPI_ATTR VkResult VKAPI_CALL vkGetPerformanceStatisticsMVK(
+	VkDevice                                    device,
+	MVKPerformanceStatistics*            		pPerf,
+	size_t*                                     pPerfSize);
+
+/**
+ * Returns a human readable version of the MoltenVK and Vulkan versions.
+ *
+ * This function is provided as a convenience for reporting. Use the MVK_VERSION, 
+ * VK_API_VERSION_1_0, and VK_HEADER_VERSION macros for programmatically accessing
+ * the corresponding version numbers.
+ */
+VKAPI_ATTR void VKAPI_CALL vkGetVersionStringsMVK(
+    char*                                       pMoltenVersionStringBuffer,
+    uint32_t                                    moltenVersionStringBufferLength,
+    char*                                       pVulkanVersionStringBuffer,
+    uint32_t                                    vulkanVersionStringBufferLength);
+
+/**
+ * Sets the number of threads in a workgroup for a compute kernel.
+ *
+ * This needs to be called if you are creating compute shader modules from MSL
+ * source code or MSL compiled code. Workgroup size is determined automatically
+ * if you're using SPIR-V.
+ *
+ * This function is not supported by the Vulkan SDK Loader and Layers framework.
+ * The VkShaderModule object you provide here must have been retrieved directly from
+ * MoltenVK, and not through the Vulkan SDK Loader and Layers framework. Opaque Vulkan
+ * objects are often changed by layers, and passing them from one layer to another,
+ * or from a layer directly to MoltenVK, will result in undefined behaviour.
+ */
+VKAPI_ATTR void VKAPI_CALL vkSetWorkgroupSizeMVK(
+    VkShaderModule                              shaderModule,
+    uint32_t                                    x,
+    uint32_t                                    y,
+    uint32_t                                    z);
+
+#ifdef __OBJC__
+
+/**
+ * Returns, in the pMTLDevice pointer, the MTLDevice used by the VkPhysicalDevice.
+ *
+ * This function is not supported by the Vulkan SDK Loader and Layers framework.
+ * The VkPhysicalDevice object you provide here must have been retrieved directly from
+ * MoltenVK, and not through the Vulkan SDK Loader and Layers framework. Opaque Vulkan
+ * objects are often changed by layers, and passing them from one layer to another,
+ * or from a layer directly to MoltenVK, will result in undefined behaviour.
+ */
+VKAPI_ATTR void VKAPI_CALL vkGetMTLDeviceMVK(
+    VkPhysicalDevice                           physicalDevice,
+    id<MTLDevice>*                             pMTLDevice);
+
+/**
+ * Sets the VkImage to use the specified MTLTexture.
+ *
+ * Any differences in the properties of mtlTexture and this image will modify the
+ * properties of this image.
+ *
+ * If a MTLTexture has already been created for this image, it will be destroyed.
+ *
+ * Returns VK_SUCCESS.
+ *
+ * This function is not supported by the Vulkan SDK Loader and Layers framework.
+ * The VkImage object you provide here must have been retrieved directly from
+ * MoltenVK, and not through the Vulkan SDK Loader and Layers framework. Opaque Vulkan
+ * objects are often changed by layers, and passing them from one layer to another,
+ * or from a layer directly to MoltenVK, will result in undefined behaviour.
+ */
+VKAPI_ATTR VkResult VKAPI_CALL vkSetMTLTextureMVK(
+    VkImage                                     image,
+    id<MTLTexture>                              mtlTexture);
+
+/**
+ * Returns, in the pMTLTexture pointer, the MTLTexture currently underlaying the VkImage.
+ *
+ * This function is not supported by the Vulkan SDK Loader and Layers framework.
+ * The VkImage object you provide here must have been retrieved directly from
+ * MoltenVK, and not through the Vulkan SDK Loader and Layers framework. Opaque Vulkan
+ * objects are often changed by layers, and passing them from one layer to another,
+ * or from a layer directly to MoltenVK, will result in undefined behaviour.
+ */
+VKAPI_ATTR void VKAPI_CALL vkGetMTLTextureMVK(
+    VkImage                                     image,
+    id<MTLTexture>*                             pMTLTexture);
+
+/**
+* Returns, in the pMTLBuffer pointer, the MTLBuffer currently underlaying the VkBuffer.
+*
+* This function is not supported by the Vulkan SDK Loader and Layers framework.
+* The VkBuffer object you provide here must have been retrieved directly from
+* MoltenVK, and not through the Vulkan SDK Loader and Layers framework. Opaque Vulkan
+* objects are often changed by layers, and passing them from one layer to another,
+* or from a layer directly to MoltenVK, will result in undefined behaviour.
+*/
+VKAPI_ATTR void VKAPI_CALL vkGetMTLBufferMVK(
+    VkBuffer                                    buffer,
+    id<MTLBuffer>*                              pMTLBuffer);
+
+/**
+ * Indicates that a VkImage should use an IOSurface to underlay the Metal texture.
+ *
+ * If ioSurface is not null, it will be used as the IOSurface, and any differences
+ * in the properties of that IOSurface will modify the properties of this image.
+ *
+ * If ioSurface is null, this image will create and use an IOSurface
+ * whose properties are compatible with the properties of this image.
+ *
+ * If a MTLTexture has already been created for this image, it will be destroyed.
+ *
+ * IOSurfaces are supported on the following platforms:
+ *   -  macOS 10.11 and above
+ *   -  iOS 11.0 and above
+ *
+ * To enable IOSurface support, ensure the Deployment Target build setting
+ * (MACOSX_DEPLOYMENT_TARGET or IPHONEOS_DEPLOYMENT_TARGET) is set to at least
+ * one of the values above when compiling MoltenVK, and any app that uses MoltenVK.
+ *
+ * Returns:
+ *   - VK_SUCCESS.
+ *   - VK_ERROR_FEATURE_NOT_PRESENT if IOSurfaces are not supported on the platform.
+ *   - VK_ERROR_INITIALIZATION_FAILED if ioSurface is specified and is not compatible with this VkImage.
+ *
+ * This function is not supported by the Vulkan SDK Loader and Layers framework.
+ * The VkImage object you provide here must have been retrieved directly from
+ * MoltenVK, and not through the Vulkan SDK Loader and Layers framework. Opaque Vulkan
+ * objects are often changed by layers, and passing them from one layer to another,
+ * or from a layer directly to MoltenVK, will result in undefined behaviour.
+ */
+VKAPI_ATTR VkResult VKAPI_CALL vkUseIOSurfaceMVK(
+    VkImage                                     image,
+    IOSurfaceRef                                ioSurface);
+
+/**
+ * Returns, in the pIOSurface pointer, the IOSurface currently underlaying the VkImage,
+ * as set by the useIOSurfaceMVK() function, or returns null if the VkImage is not using
+ * an IOSurface, or if the platform does not support IOSurfaces.
+ *
+ * This function is not supported by the Vulkan SDK Loader and Layers framework.
+ * The VkImage object you provide here must have been retrieved directly from
+ * MoltenVK, and not through the Vulkan SDK Loader and Layers framework. Opaque Vulkan
+ * objects are often changed by layers, and passing them from one layer to another,
+ * or from a layer directly to MoltenVK, will result in undefined behaviour.
+ */
+VKAPI_ATTR void VKAPI_CALL vkGetIOSurfaceMVK(
+    VkImage                                     image,
+    IOSurfaceRef*                               pIOSurface);
+
+#endif // __OBJC__
+
+
+#pragma mark -
+#pragma mark Shaders
+
+/**
+ * NOTE: Shader code should be submitted as SPIR-V. Although some simple direct MSL shaders may work,
+ * direct loading of MSL source code or compiled MSL code is not officially supported at this time.
+ * Future versions of MoltenVK may support direct MSL submission again.
+ *
+ * Enumerates the magic number values to set in the MVKMSLSPIRVHeader when
+ * submitting a SPIR-V stream that contains either Metal Shading Language source
+ * code or Metal Shading Language compiled binary code in place of SPIR-V code.
+ */
+typedef enum {
+    kMVKMagicNumberSPIRVCode        = 0x07230203,    /**< SPIR-V stream contains standard SPIR-V code. */
+    kMVKMagicNumberMSLSourceCode    = 0x19960412,    /**< SPIR-V stream contains Metal Shading Language source code. */
+    kMVKMagicNumberMSLCompiledCode  = 0x19981215,    /**< SPIR-V stream contains Metal Shading Language compiled binary code. */
+} MVKMSLMagicNumber;
+
+/**
+ * NOTE: Shader code should be submitted as SPIR-V. Although some simple direct MSL shaders may work,
+ * direct loading of MSL source code or compiled MSL code is not officially supported at this time.
+ * Future versions of MoltenVK may support direct MSL submission again.
+ *
+ * Describes the header at the start of an SPIR-V stream, when it contains either
+ * Metal Shading Language source code or Metal Shading Language compiled binary code.
+ *
+ * To submit MSL source code to the vkCreateShaderModule() function in place of SPIR-V
+ * code, prepend a MVKMSLSPIRVHeader containing the kMVKMagicNumberMSLSourceCode magic
+ * number to the MSL source code. The MSL source code must be null-terminated.
+ *
+ * To submit MSL compiled binary code to the vkCreateShaderModule() function in place of
+ * SPIR-V code, prepend a MVKMSLSPIRVHeader containing the kMVKMagicNumberMSLCompiledCode
+ * magic number to the MSL compiled binary code.
+ *
+ * In both cases, the pCode element of VkShaderModuleCreateInfo should pointer to the
+ * location of the MVKMSLSPIRVHeader, and the MSL code should start at the byte immediately
+ * after the MVKMSLSPIRVHeader.
+ *
+ * The codeSize element of VkShaderModuleCreateInfo should be set to the entire size of
+ * the submitted code memory, including the additional sizeof(MVKMSLSPIRVHeader) bytes
+ * taken up by the MVKMSLSPIRVHeader, and, in the case of MSL source code, including
+ * the null-terminator byte.
+ */
+typedef uint32_t MVKMSLSPIRVHeader;
+
+
+#endif // VK_NO_PROTOTYPES
+
+
+#ifdef __cplusplus
+}
+#endif	//  __cplusplus
+
+#endif
diff --git a/include/vk_video/vulkan_video_codec_h264std.h b/include/vk_video/vulkan_video_codec_h264std.h
new file mode 100644
index 0000000..f8c0cef
--- /dev/null
+++ b/include/vk_video/vulkan_video_codec_h264std.h
@@ -0,0 +1,299 @@
+/*
+** Copyright (c) 2019-2021 The Khronos Group Inc.
+**
+** SPDX-License-Identifier: Apache-2.0
+*/
+
+#ifndef VULKAN_VIDEO_CODEC_H264STD_H_
+#define VULKAN_VIDEO_CODEC_H264STD_H_ 1
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "vk_video/vulkan_video_codecs_common.h"
+
+// Vulkan 0.9 provisional Vulkan video H.264 encode and decode std specification version number
+#define VK_STD_VULKAN_VIDEO_CODEC_H264_API_VERSION_0_9 VK_MAKE_VIDEO_STD_VERSION(0, 9, 0) // Patch version should always be set to 0
+
+// Format must be in the form XX.XX where the first two digits are the major and the second two, the minor.
+#define VK_STD_VULKAN_VIDEO_CODEC_H264_SPEC_VERSION   VK_STD_VULKAN_VIDEO_CODEC_H264_API_VERSION_0_9
+#define VK_STD_VULKAN_VIDEO_CODEC_H264_EXTENSION_NAME "VK_STD_vulkan_video_codec_h264"
+
+// *************************************************
+// Video H.264 common definitions:
+// *************************************************
+
+typedef enum StdVideoH264ChromaFormatIdc {
+    std_video_h264_chroma_format_idc_monochrome  = 0,
+    std_video_h264_chroma_format_idc_420         = 1,
+    std_video_h264_chroma_format_idc_422         = 2,
+    std_video_h264_chroma_format_idc_444         = 3,
+} StdVideoH264ChromaFormatIdc;
+
+typedef enum StdVideoH264ProfileIdc {
+    std_video_h264_profile_idc_baseline             = 66, /* Only constrained baseline is supported */
+    std_video_h264_profile_idc_main                 = 77,
+    std_video_h264_profile_idc_high                 = 100,
+    std_video_h264_profile_idc_high_444_predictive  = 244,
+    std_video_h264_profile_idc_invalid              = 0x7FFFFFFF
+} StdVideoH264ProfileIdc;
+
+typedef enum StdVideoH264Level {
+    std_video_h264_level_1_0 = 0,
+    std_video_h264_level_1_1 = 1,
+    std_video_h264_level_1_2 = 2,
+    std_video_h264_level_1_3 = 3,
+    std_video_h264_level_2_0 = 4,
+    std_video_h264_level_2_1 = 5,
+    std_video_h264_level_2_2 = 6,
+    std_video_h264_level_3_0 = 7,
+    std_video_h264_level_3_1 = 8,
+    std_video_h264_level_3_2 = 9,
+    std_video_h264_level_4_0 = 10,
+    std_video_h264_level_4_1 = 11,
+    std_video_h264_level_4_2 = 12,
+    std_video_h264_level_5_0 = 13,
+    std_video_h264_level_5_1 = 14,
+    std_video_h264_level_5_2 = 15,
+    std_video_h264_level_6_0 = 16,
+    std_video_h264_level_6_1 = 17,
+    std_video_h264_level_6_2 = 18,
+    std_video_h264_level_invalid = 0x7FFFFFFF
+} StdVideoH264Level;
+
+typedef enum StdVideoH264PocType {
+    std_video_h264_poc_type_0 = 0,
+    std_video_h264_poc_type_1 = 1,
+    std_video_h264_poc_type_2 = 2,
+    std_video_h264_poc_type_invalid = 0x7FFFFFFF
+} StdVideoH264PocType;
+
+typedef enum StdVideoH264AspectRatioIdc {
+    std_video_h264_aspect_ratio_idc_unspecified = 0,
+    std_video_h264_aspect_ratio_idc_square = 1,
+    std_video_h264_aspect_ratio_idc_12_11 = 2,
+    std_video_h264_aspect_ratio_idc_10_11 = 3,
+    std_video_h264_aspect_ratio_idc_16_11 = 4,
+    std_video_h264_aspect_ratio_idc_40_33 = 5,
+    std_video_h264_aspect_ratio_idc_24_11 = 6,
+    std_video_h264_aspect_ratio_idc_20_11 = 7,
+    std_video_h264_aspect_ratio_idc_32_11 = 8,
+    std_video_h264_aspect_ratio_idc_80_33 = 9,
+    std_video_h264_aspect_ratio_idc_18_11 = 10,
+    std_video_h264_aspect_ratio_idc_15_11 = 11,
+    std_video_h264_aspect_ratio_idc_64_33 = 12,
+    std_video_h264_aspect_ratio_idc_160_99 = 13,
+    std_video_h264_aspect_ratio_idc_4_3 = 14,
+    std_video_h264_aspect_ratio_idc_3_2 = 15,
+    std_video_h264_aspect_ratio_idc_2_1 = 16,
+    std_video_h264_aspect_ratio_idc_extended_sar = 255,
+    std_video_h264_aspect_ratio_idc_invalid = 0x7FFFFFFF
+} StdVideoH264AspectRatioIdc;
+
+typedef enum StdVideoH264WeightedBiPredIdc {
+    std_video_h264_default_weighted_b_slices_prediction_idc = 0,
+    std_video_h264_explicit_weighted_b_slices_prediction_idc = 1,
+    std_video_h264_implicit_weighted_b_slices_prediction_idc = 2,
+    std_video_h264_invalid_weighted_b_slices_prediction_idc = 0x7FFFFFFF
+} StdVideoH264WeightedBiPredIdc;
+
+typedef enum StdVideoH264ModificationOfPicNumsIdc {
+    std_video_h264_modification_of_pic_nums_idc_short_term_subtract = 0,
+    std_video_h264_modification_of_pic_nums_idc_short_term_add = 1,
+    std_video_h264_modification_of_pic_nums_idc_long_term = 2,
+    std_video_h264_modification_of_pic_nums_idc_end = 3,
+    std_video_h264_modification_of_pic_nums_idc_invalid = 0x7FFFFFFF
+} StdVideoH264ModificationOfPicNumsIdc;
+
+typedef enum StdVideoH264MemMgmtControlOp {
+    std_video_h264_mem_mgmt_control_op_end = 0,
+    std_video_h264_mem_mgmt_control_op_unmark_short_term = 1,
+    std_video_h264_mem_mgmt_control_op_unmark_long_term = 2,
+    std_video_h264_mem_mgmt_control_op_mark_long_term = 3,
+    std_video_h264_mem_mgmt_control_op_set_max_long_term_index = 4,
+    std_video_h264_mem_mgmt_control_op_unmark_all = 5,
+    std_video_h264_mem_mgmt_control_op_mark_current_as_long_term = 6,
+    std_video_h264_mem_mgmt_control_op_invalid = 0x7FFFFFFF
+} StdVideoH264MemMgmtControlOp;
+
+typedef enum StdVideoH264CabacInitIdc {
+    std_video_h264_cabac_init_idc_0 = 0,
+    std_video_h264_cabac_init_idc_1 = 1,
+    std_video_h264_cabac_init_idc_2 = 2,
+    std_video_h264_cabac_init_idc_invalid = 0x7FFFFFFF
+} StdVideoH264CabacInitIdc;
+
+typedef enum StdVideoH264DisableDeblockingFilterIdc {
+    std_video_h264_disable_deblocking_filter_idc_disabled = 0,
+    std_video_h264_disable_deblocking_filter_idc_enabled = 1,
+    std_video_h264_disable_deblocking_filter_idc_partial = 2,
+    std_video_h264_disable_deblocking_filter_idc_invalid = 0x7FFFFFFF
+} StdVideoH264DisableDeblockingFilterIdc;
+
+typedef enum StdVideoH264PictureType {
+    std_video_h264_picture_type_i = 0,
+    std_video_h264_picture_type_p = 1,
+    std_video_h264_picture_type_b = 2,
+    std_video_h264_picture_type_invalid = 0x7FFFFFFF
+} StdVideoH264PictureType;
+
+typedef enum StdVideoH264SliceType {
+    std_video_h264_slice_type_i = 0,
+    std_video_h264_slice_type_p = 1,
+    std_video_h264_slice_type_b = 2,
+    std_video_h264_slice_type_invalid = 0x7FFFFFFF
+} StdVideoH264SliceType;
+
+typedef enum StdVideoH264NonVclNaluType {
+    std_video_h264_non_vcl_nalu_type_sps = 0,
+    std_video_h264_non_vcl_nalu_type_pps = 1,
+    std_video_h264_non_vcl_nalu_type_aud = 2,
+    std_video_h264_non_vcl_nalu_type_prefix = 3,
+    std_video_h264_non_vcl_nalu_type_end_of_sequence = 4,
+    std_video_h264_non_vcl_nalu_type_end_of_stream = 5,
+    std_video_h264_non_vcl_nalu_type_precoded = 6,
+    std_video_h264_non_vcl_nalu_type_invalid = 0x7FFFFFFF
+} StdVideoH264NonVclNaluType;
+
+typedef struct StdVideoH264SpsVuiFlags {
+    uint32_t aspect_ratio_info_present_flag:1;
+    uint32_t overscan_info_present_flag:1;
+    uint32_t overscan_appropriate_flag:1;
+    uint32_t video_signal_type_present_flag:1;
+    uint32_t video_full_range_flag:1;
+    uint32_t color_description_present_flag:1;
+    uint32_t chroma_loc_info_present_flag:1;
+    uint32_t timing_info_present_flag:1;
+    uint32_t fixed_frame_rate_flag:1;
+    uint32_t bitstream_restriction_flag:1;
+    uint32_t nal_hrd_parameters_present_flag:1;
+    uint32_t vcl_hrd_parameters_present_flag:1;
+} StdVideoH264SpsVuiFlags;
+
+typedef struct StdVideoH264HrdParameters {
+    uint8_t                    cpb_cnt_minus1;
+    uint8_t                    bit_rate_scale;
+    uint8_t                    cpb_size_scale;
+    uint32_t                   bit_rate_value_minus1[32];
+    uint32_t                   cpb_size_value_minus1[32];
+    uint8_t                    cbr_flag[32];
+    uint32_t                   initial_cpb_removal_delay_length_minus1;
+    uint32_t                   cpb_removal_delay_length_minus1;
+    uint32_t                   dpb_output_delay_length_minus1;
+    uint32_t                   time_offset_length;
+} StdVideoH264HrdParameters;
+
+typedef struct StdVideoH264SequenceParameterSetVui {
+    StdVideoH264AspectRatioIdc  aspect_ratio_idc;
+    uint16_t                    sar_width;
+    uint16_t                    sar_height;
+    uint8_t                     video_format;
+    uint8_t                     color_primaries;
+    uint8_t                     transfer_characteristics;
+    uint8_t                     matrix_coefficients;
+    uint32_t                    num_units_in_tick;
+    uint32_t                    time_scale;
+    StdVideoH264HrdParameters   hrd_parameters;
+    uint8_t                     num_reorder_frames;
+    uint8_t                     max_dec_frame_buffering;
+    StdVideoH264SpsVuiFlags     flags;
+} StdVideoH264SequenceParameterSetVui;
+
+typedef struct StdVideoH264SpsFlags {
+    uint32_t constraint_set0_flag:1;
+    uint32_t constraint_set1_flag:1;
+    uint32_t constraint_set2_flag:1;
+    uint32_t constraint_set3_flag:1;
+    uint32_t constraint_set4_flag:1;
+    uint32_t constraint_set5_flag:1;
+    uint32_t direct_8x8_inference_flag:1;
+    uint32_t mb_adaptive_frame_field_flag:1;
+    uint32_t frame_mbs_only_flag:1;
+    uint32_t delta_pic_order_always_zero_flag:1;
+    uint32_t residual_colour_transform_flag:1;
+    uint32_t gaps_in_frame_num_value_allowed_flag:1;
+    uint32_t first_picture_after_seek_flag:1; // where is this being documented?
+    uint32_t qpprime_y_zero_transform_bypass_flag:1;
+    uint32_t frame_cropping_flag:1;
+    uint32_t scaling_matrix_present_flag:1;
+    uint32_t vui_parameters_present_flag:1;
+} StdVideoH264SpsFlags;
+
+typedef struct StdVideoH264ScalingLists
+{
+    // scaling_list_present_mask has one bit for each
+    // seq_scaling_list_present_flag[i] for SPS OR
+    // pic_scaling_list_present_flag[i] for PPS,
+    // bit 0 - 5 are for each entry of ScalingList4x4
+    // bit 6 - 7 are for each entry plus 6 for ScalingList8x8
+    uint8_t scaling_list_present_mask;
+    // use_default_scaling_matrix_mask has one bit for each
+    // UseDefaultScalingMatrix4x4Flag[ i ] and
+    // UseDefaultScalingMatrix8x8Flag[ i - 6 ] for SPS OR PPS
+    // bit 0 - 5 are for each entry of ScalingList4x4
+    // bit 6 - 7 are for each entry plus 6 for ScalingList8x8
+    uint8_t use_default_scaling_matrix_mask;
+    uint8_t ScalingList4x4[6][16];
+    uint8_t ScalingList8x8[2][64];
+} StdVideoH264ScalingLists;
+
+typedef struct StdVideoH264SequenceParameterSet
+{
+    StdVideoH264ProfileIdc               profile_idc;
+    StdVideoH264Level                    level_idc;
+    uint8_t                              seq_parameter_set_id;
+    StdVideoH264ChromaFormatIdc          chroma_format_idc;
+    uint8_t                              bit_depth_luma_minus8;
+    uint8_t                              bit_depth_chroma_minus8;
+    uint8_t                              log2_max_frame_num_minus4;
+    StdVideoH264PocType                  pic_order_cnt_type;
+    uint8_t                              log2_max_pic_order_cnt_lsb_minus4;
+    int32_t                              offset_for_non_ref_pic;
+    int32_t                              offset_for_top_to_bottom_field;
+    uint8_t                              num_ref_frames_in_pic_order_cnt_cycle;
+    uint8_t                              max_num_ref_frames;
+    uint32_t                             pic_width_in_mbs_minus1;
+    uint32_t                             pic_height_in_map_units_minus1;
+    uint32_t                             frame_crop_left_offset;
+    uint32_t                             frame_crop_right_offset;
+    uint32_t                             frame_crop_top_offset;
+    uint32_t                             frame_crop_bottom_offset;
+    StdVideoH264SpsFlags                 flags;
+    int32_t                              offset_for_ref_frame[255]; // The number of valid values are defined by the num_ref_frames_in_pic_order_cnt_cycle
+    StdVideoH264ScalingLists*            pScalingLists;             // Must be a valid pointer if scaling_matrix_present_flag is set
+    StdVideoH264SequenceParameterSetVui* pSequenceParameterSetVui;  // Must be a valid pointer if StdVideoH264SpsFlags:vui_parameters_present_flag is set
+} StdVideoH264SequenceParameterSet;
+
+typedef struct StdVideoH264PpsFlags {
+    uint32_t transform_8x8_mode_flag:1;
+    uint32_t redundant_pic_cnt_present_flag:1;
+    uint32_t constrained_intra_pred_flag:1;
+    uint32_t deblocking_filter_control_present_flag:1;
+    uint32_t weighted_bipred_idc_flag:1;
+    uint32_t weighted_pred_flag:1;
+    uint32_t pic_order_present_flag:1;
+    uint32_t entropy_coding_mode_flag:1;
+    uint32_t scaling_matrix_present_flag:1;
+} StdVideoH264PpsFlags;
+
+typedef struct StdVideoH264PictureParameterSet
+{
+    uint8_t                       seq_parameter_set_id;
+    uint8_t                       pic_parameter_set_id;
+    uint8_t                       num_ref_idx_l0_default_active_minus1;
+    uint8_t                       num_ref_idx_l1_default_active_minus1;
+    StdVideoH264WeightedBiPredIdc weighted_bipred_idc;
+    int8_t                        pic_init_qp_minus26;
+    int8_t                        pic_init_qs_minus26;
+    int8_t                        chroma_qp_index_offset;
+    int8_t                        second_chroma_qp_index_offset;
+    StdVideoH264PpsFlags          flags;
+    StdVideoH264ScalingLists*     pScalingLists; // Must be a valid pointer if  StdVideoH264PpsFlags::scaling_matrix_present_flag is set.
+} StdVideoH264PictureParameterSet;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif // VULKAN_VIDEO_CODEC_H264STD_H_
diff --git a/include/vk_video/vulkan_video_codec_h264std_decode.h b/include/vk_video/vulkan_video_codec_h264std_decode.h
new file mode 100644
index 0000000..2b4fc64
--- /dev/null
+++ b/include/vk_video/vulkan_video_codec_h264std_decode.h
@@ -0,0 +1,87 @@
+/*
+** Copyright (c) 2019-2020 The Khronos Group Inc.
+**
+** SPDX-License-Identifier: Apache-2.0
+*/
+
+#ifndef VULKAN_VIDEO_CODEC_H264STD_DECODE_H_
+#define VULKAN_VIDEO_CODEC_H264STD_DECODE_H_ 1
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "vk_video/vulkan_video_codec_h264std.h"
+
+// *************************************************
+// Video H.264 Decode related parameters:
+// *************************************************
+
+typedef struct StdVideoDecodeH264PictureInfoFlags {
+    uint32_t field_pic_flag:1;             // Is field picture
+    uint32_t is_intra:1;                   // Is intra picture
+    uint32_t bottom_field_flag:1;          // bottom (true) or top (false) field if field_pic_flag is set.
+    uint32_t is_reference:1;               // This only applies to picture info, and not to the DPB lists.
+    uint32_t complementary_field_pair:1;   // complementary field pair, complementary non-reference field pair, complementary reference field pair
+} StdVideoDecodeH264PictureInfoFlags;
+
+typedef struct StdVideoDecodeH264PictureInfo {
+    uint8_t  seq_parameter_set_id;          // Selecting SPS from the Picture Parameters
+    uint8_t  pic_parameter_set_id;          // Selecting PPS from the Picture Parameters and the SPS
+    uint16_t reserved;                      // for structure members 32-bit packing/alignment
+    uint16_t frame_num;                     // 7.4.3 Slice header semantics
+    uint16_t idr_pic_id;                    // 7.4.3 Slice header semantics
+    // PicOrderCnt is based on TopFieldOrderCnt and BottomFieldOrderCnt. See 8.2.1 Decoding process for picture order count type 0 - 2
+    int32_t  PicOrderCnt[2];                // TopFieldOrderCnt and BottomFieldOrderCnt fields.
+    StdVideoDecodeH264PictureInfoFlags flags;
+} StdVideoDecodeH264PictureInfo;
+
+typedef struct StdVideoDecodeH264ReferenceInfoFlags {
+    uint32_t top_field_flag:1;             // Reference is used for top field reference.
+    uint32_t bottom_field_flag:1;          // Reference is used for bottom field reference.
+    uint32_t is_long_term:1;               // this is a long term reference
+    uint32_t is_non_existing:1;            // Must be handled in accordance with 8.2.5.2: Decoding process for gaps in frame_num
+} StdVideoDecodeH264ReferenceInfoFlags;
+
+typedef struct StdVideoDecodeH264ReferenceInfo {
+    // FrameNum = is_long_term ?  long_term_frame_idx : frame_num
+    uint16_t FrameNum;                     // 7.4.3.3 Decoded reference picture marking semantics
+    uint16_t reserved;                     // for structure members 32-bit packing/alignment
+    int32_t  PicOrderCnt[2];               // TopFieldOrderCnt and BottomFieldOrderCnt fields.
+    StdVideoDecodeH264ReferenceInfoFlags flags;
+} StdVideoDecodeH264ReferenceInfo;
+
+typedef struct StdVideoDecodeH264MvcElementFlags {
+    uint32_t non_idr:1;
+    uint32_t anchor_pic:1;
+    uint32_t inter_view:1;
+} StdVideoDecodeH264MvcElementFlags;
+
+typedef struct StdVideoDecodeH264MvcElement {
+    StdVideoDecodeH264MvcElementFlags flags;
+    uint16_t viewOrderIndex;
+    uint16_t viewId;
+    uint16_t temporalId; // move out?
+    uint16_t priorityId; // move out?
+    uint16_t numOfAnchorRefsInL0;
+    uint16_t viewIdOfAnchorRefsInL0[15];
+    uint16_t numOfAnchorRefsInL1;
+    uint16_t viewIdOfAnchorRefsInL1[15];
+    uint16_t numOfNonAnchorRefsInL0;
+    uint16_t viewIdOfNonAnchorRefsInL0[15];
+    uint16_t numOfNonAnchorRefsInL1;
+    uint16_t viewIdOfNonAnchorRefsInL1[15];
+} StdVideoDecodeH264MvcElement;
+
+typedef struct StdVideoDecodeH264Mvc {
+    uint32_t viewId0;
+    uint32_t mvcElementCount;
+    StdVideoDecodeH264MvcElement* pMvcElements;
+} StdVideoDecodeH264Mvc;
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif // VULKAN_VIDEO_CODEC_H264STD_DECODE_H_
diff --git a/include/vk_video/vulkan_video_codec_h264std_encode.h b/include/vk_video/vulkan_video_codec_h264std_encode.h
new file mode 100644
index 0000000..7184562
--- /dev/null
+++ b/include/vk_video/vulkan_video_codec_h264std_encode.h
@@ -0,0 +1,94 @@
+/*
+** Copyright (c) 2019-2021 The Khronos Group Inc.
+**
+** SPDX-License-Identifier: Apache-2.0
+*/
+
+#ifndef VULKAN_VIDEO_CODEC_H264STD_ENCODE_H_
+#define VULKAN_VIDEO_CODEC_H264STD_ENCODE_H_ 1
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "vk_video/vulkan_video_codec_h264std.h"
+
+// *************************************************
+// Video H.264 Encode related parameters:
+// *************************************************
+
+typedef struct StdVideoEncodeH264SliceHeaderFlags {
+    uint32_t idr_flag:1;
+    uint32_t is_reference_flag:1;
+    uint32_t num_ref_idx_active_override_flag:1;
+    uint32_t no_output_of_prior_pics_flag:1;
+    uint32_t long_term_reference_flag:1;
+    uint32_t adaptive_ref_pic_marking_mode_flag:1;
+    uint32_t no_prior_references_available_flag:1;
+} StdVideoEncodeH264SliceHeaderFlags;
+
+typedef struct StdVideoEncodeH264PictureInfoFlags {
+    uint32_t idr_flag:1;
+    uint32_t is_reference_flag:1;
+    uint32_t long_term_reference_flag:1;
+} StdVideoEncodeH264PictureInfoFlags;
+
+typedef struct StdVideoEncodeH264RefMgmtFlags {
+    uint32_t ref_pic_list_modification_l0_flag:1;
+    uint32_t ref_pic_list_modification_l1_flag:1;
+} StdVideoEncodeH264RefMgmtFlags;
+
+typedef struct StdVideoEncodeH264RefListModEntry {
+    StdVideoH264ModificationOfPicNumsIdc modification_of_pic_nums_idc;
+    uint16_t                             abs_diff_pic_num_minus1;
+    uint16_t                             long_term_pic_num;
+} StdVideoEncodeH264RefListModEntry;
+
+typedef struct StdVideoEncodeH264RefPicMarkingEntry {
+    StdVideoH264MemMgmtControlOp  operation;
+    uint16_t                      difference_of_pic_nums_minus1;
+    uint16_t                      long_term_pic_num;
+    uint16_t                      long_term_frame_idx;
+    uint16_t                      max_long_term_frame_idx_plus1;
+} StdVideoEncodeH264RefPicMarkingEntry;
+
+typedef struct StdVideoEncodeH264RefMemMgmtCtrlOperations {
+    StdVideoEncodeH264RefMgmtFlags        flags;
+    uint8_t                               refList0ModOpCount;
+    StdVideoEncodeH264RefListModEntry*    pRefList0ModOperations;
+    uint8_t                               refList1ModOpCount;
+    StdVideoEncodeH264RefListModEntry*    pRefList1ModOperations;
+    uint8_t                               refPicMarkingOpCount;
+    StdVideoEncodeH264RefPicMarkingEntry* pRefPicMarkingOperations;
+} StdVideoEncodeH264RefMemMgmtCtrlOperations;
+
+typedef struct StdVideoEncodeH264PictureInfo {
+    StdVideoEncodeH264PictureInfoFlags   flags;
+    StdVideoH264PictureType              pictureType;
+    uint32_t                             frameNum;
+    uint32_t                             pictureOrderCount;
+    uint16_t                             long_term_pic_num;
+    uint16_t                             long_term_frame_idx;
+} StdVideoEncodeH264PictureInfo;
+
+typedef struct StdVideoEncodeH264SliceHeader {
+    StdVideoEncodeH264SliceHeaderFlags          flags;
+    StdVideoH264SliceType                       slice_type;
+    uint8_t                                     seq_parameter_set_id;
+    uint8_t                                     pic_parameter_set_id;
+    uint16_t                                    idr_pic_id;
+    uint8_t                                     num_ref_idx_l0_active_minus1;
+    uint8_t                                     num_ref_idx_l1_active_minus1;
+    StdVideoH264CabacInitIdc                    cabac_init_idc;
+    StdVideoH264DisableDeblockingFilterIdc      disable_deblocking_filter_idc;
+    int8_t                                      slice_alpha_c0_offset_div2;
+    int8_t                                      slice_beta_offset_div2;
+    StdVideoEncodeH264RefMemMgmtCtrlOperations* pMemMgmtCtrlOperations;
+} StdVideoEncodeH264SliceHeader;
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif // VULKAN_VIDEO_CODEC_H264STD_ENCODE_H_
diff --git a/include/vk_video/vulkan_video_codec_h265std.h b/include/vk_video/vulkan_video_codec_h265std.h
new file mode 100644
index 0000000..185b550
--- /dev/null
+++ b/include/vk_video/vulkan_video_codec_h265std.h
@@ -0,0 +1,341 @@
+/*
+** Copyright (c) 2019-2021 The Khronos Group Inc.
+**
+** SPDX-License-Identifier: Apache-2.0
+*/
+
+#ifndef VULKAN_VIDEO_CODEC_H265STD_H_
+#define VULKAN_VIDEO_CODEC_H265STD_H_ 1
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "vk_video/vulkan_video_codecs_common.h"
+
+// Vulkan 0.5 version number WIP
+#define VK_STD_VULKAN_VIDEO_CODEC_H265_API_VERSION_0_5 VK_MAKE_VIDEO_STD_VERSION(0, 5, 0) // Patch version should always be set to 0
+
+// Format must be in the form XX.XX where the first two digits are the major and the second two, the minor.
+#define VK_STD_VULKAN_VIDEO_CODEC_H265_SPEC_VERSION   VK_STD_VULKAN_VIDEO_CODEC_H265_API_VERSION_0_5
+#define VK_STD_VULKAN_VIDEO_CODEC_H265_EXTENSION_NAME "VK_STD_vulkan_video_codec_h265"
+
+typedef enum StdVideoH265ChromaFormatIdc {
+    std_video_h265_chroma_format_idc_monochrome  = 0,
+    std_video_h265_chroma_format_idc_420         = 1,
+    std_video_h265_chroma_format_idc_422         = 2,
+    std_video_h265_chroma_format_idc_444         = 3,
+} StdVideoH265ChromaFormatIdc;
+
+typedef enum StdVideoH265ProfileIdc {
+    std_video_h265_profile_idc_main                     = 1,
+    std_video_h265_profile_idc_main_10                  = 2,
+    std_video_h265_profile_idc_main_still_picture       = 3,
+    std_video_h265_profile_idc_format_range_extensions  = 4,
+    std_video_h265_profile_idc_scc_extensions           = 9,
+    std_video_h265_profile_idc_invalid                  = 0x7FFFFFFF
+} StdVideoH265ProfileIdc;
+
+typedef enum StdVideoH265Level {
+    std_video_h265_level_1_0 = 0,
+    std_video_h265_level_2_0 = 1,
+    std_video_h265_level_2_1 = 2,
+    std_video_h265_level_3_0 = 3,
+    std_video_h265_level_3_1 = 4,
+    std_video_h265_level_4_0 = 5,
+    std_video_h265_level_4_1 = 6,
+    std_video_h265_level_5_0 = 7,
+    std_video_h265_level_5_1 = 8,
+    std_video_h265_level_5_2 = 9,
+    std_video_h265_level_6_0 = 10,
+    std_video_h265_level_6_1 = 11,
+    std_video_h265_level_6_2 = 12,
+    std_video_h265_level_invalid = 0x7FFFFFFF
+} StdVideoH265Level;
+
+
+typedef struct StdVideoH265DecPicBufMgr
+{
+    uint32_t max_latency_increase_plus1[7];
+    uint8_t  max_dec_pic_buffering_minus1[7];
+    uint8_t  max_num_reorder_pics[7];
+} StdVideoH265DecPicBufMgr;
+
+typedef struct StdVideoH265SubLayerHrdParameters {
+    uint32_t bit_rate_value_minus1[32];
+    uint32_t cpb_size_value_minus1[32];
+    uint32_t cpb_size_du_value_minus1[32];
+    uint32_t bit_rate_du_value_minus1[32];
+    uint32_t cbr_flag; // each bit represents a range of CpbCounts (bit 0 - cpb_cnt_minus1) per sub-layer
+} StdVideoH265SubLayerHrdParameters;
+
+typedef struct StdVideoH265HrdFlags {
+    uint32_t nal_hrd_parameters_present_flag : 1;
+    uint32_t vcl_hrd_parameters_present_flag : 1;
+    uint32_t sub_pic_hrd_params_present_flag : 1;
+    uint32_t sub_pic_cpb_params_in_pic_timing_sei_flag : 1;
+    uint8_t  fixed_pic_rate_general_flag; // each bit represents a sublayer, bit 0 - vps_max_sub_layers_minus1
+    uint8_t  fixed_pic_rate_within_cvs_flag; // each bit represents a sublayer, bit 0 - vps_max_sub_layers_minus1
+    uint8_t  low_delay_hrd_flag; // each bit represents a sublayer, bit 0 - vps_max_sub_layers_minus1
+} StdVideoH265HrdFlags;
+
+typedef struct StdVideoH265HrdParameters {
+    uint8_t                            tick_divisor_minus2;
+    uint8_t                            du_cpb_removal_delay_increment_length_minus1;
+    uint8_t                            dpb_output_delay_du_length_minus1;
+    uint8_t                            bit_rate_scale;
+    uint8_t                            cpb_size_scale;
+    uint8_t                            cpb_size_du_scale;
+    uint8_t                            initial_cpb_removal_delay_length_minus1;
+    uint8_t                            au_cpb_removal_delay_length_minus1;
+    uint8_t                            dpb_output_delay_length_minus1;
+    uint8_t                            cpb_cnt_minus1[7];
+    uint16_t                           elemental_duration_in_tc_minus1[7];
+    StdVideoH265SubLayerHrdParameters* SubLayerHrdParametersNal[7];
+    StdVideoH265SubLayerHrdParameters* SubLayerHrdParametersVcl[7];
+    StdVideoH265HrdFlags               flags;
+} StdVideoH265HrdParameters;
+
+typedef struct StdVideoH265VpsFlags {
+    uint32_t vps_temporal_id_nesting_flag : 1;
+    uint32_t vps_sub_layer_ordering_info_present_flag : 1;
+    uint32_t vps_timing_info_present_flag : 1;
+    uint32_t vps_poc_proportional_to_timing_flag : 1;
+} StdVideoH265VpsFlags;
+
+typedef struct StdVideoH265VideoParameterSet
+{
+    uint8_t                      vps_video_parameter_set_id;
+    uint8_t                      vps_max_sub_layers_minus1;
+    uint32_t                     vps_num_units_in_tick;
+    uint32_t                     vps_time_scale;
+    uint32_t                     vps_num_ticks_poc_diff_one_minus1;
+    StdVideoH265DecPicBufMgr*    pDecPicBufMgr;
+    StdVideoH265HrdParameters*   hrd_parameters;
+    StdVideoH265VpsFlags         flags;
+} StdVideoH265VideoParameterSet;
+
+typedef struct StdVideoH265ScalingLists
+{
+    uint8_t ScalingList4x4[6][16];       // ScalingList[ 0 ][ MatrixID ][ i ] (sizeID = 0)
+    uint8_t ScalingList8x8[6][64];       // ScalingList[ 1 ][ MatrixID ][ i ] (sizeID = 1)
+    uint8_t ScalingList16x16[6][64];     // ScalingList[ 2 ][ MatrixID ][ i ] (sizeID = 2)
+    uint8_t ScalingList32x32[2][64];     // ScalingList[ 3 ][ MatrixID ][ i ] (sizeID = 3)
+    uint8_t ScalingListDCCoef16x16[6];   // scaling_list_dc_coef_minus8[ sizeID - 2 ][ matrixID ] + 8, sizeID = 2
+    uint8_t ScalingListDCCoef32x32[2];   // scaling_list_dc_coef_minus8[ sizeID - 2 ][ matrixID ] + 8. sizeID = 3
+} StdVideoH265ScalingLists;
+
+typedef struct StdVideoH265SpsVuiFlags {
+    uint32_t aspect_ratio_info_present_flag : 1;
+    uint32_t overscan_info_present_flag : 1;
+    uint32_t overscan_appropriate_flag : 1;
+    uint32_t video_signal_type_present_flag : 1;
+    uint32_t video_full_range_flag : 1;
+    uint32_t colour_description_present_flag : 1;
+    uint32_t chroma_loc_info_present_flag : 1;
+    uint32_t neutral_chroma_indication_flag : 1;
+    uint32_t field_seq_flag : 1;
+    uint32_t frame_field_info_present_flag : 1;
+    uint32_t default_display_window_flag : 1;
+    uint32_t vui_timing_info_present_flag : 1;
+    uint32_t vui_poc_proportional_to_timing_flag : 1;
+    uint32_t vui_hrd_parameters_present_flag : 1;
+    uint32_t bitstream_restriction_flag : 1;
+    uint32_t tiles_fixed_structure_flag : 1;
+    uint32_t motion_vectors_over_pic_boundaries_flag : 1;
+    uint32_t restricted_ref_pic_lists_flag : 1;
+} StdVideoH265SpsVuiFlags;
+
+typedef struct StdVideoH265SequenceParameterSetVui {
+    uint8_t                     aspect_ratio_idc;
+    uint16_t                    sar_width;
+    uint16_t                    sar_height;
+    uint8_t                     video_format;
+    uint8_t                     colour_primaries;
+    uint8_t                     transfer_characteristics;
+    uint8_t                     matrix_coeffs;
+    uint8_t                     chroma_sample_loc_type_top_field;
+    uint8_t                     chroma_sample_loc_type_bottom_field;
+    uint16_t                    def_disp_win_left_offset;
+    uint16_t                    def_disp_win_right_offset;
+    uint16_t                    def_disp_win_top_offset;
+    uint16_t                    def_disp_win_bottom_offset;
+    uint32_t                    vui_num_units_in_tick;
+    uint32_t                    vui_time_scale;
+    uint32_t                    vui_num_ticks_poc_diff_one_minus1;
+    StdVideoH265HrdParameters*  hrd_parameters;
+    uint16_t                    min_spatial_segmentation_idc;
+    uint8_t                     max_bytes_per_pic_denom;
+    uint8_t                     max_bits_per_min_cu_denom;
+    uint8_t                     log2_max_mv_length_horizontal;
+    uint8_t                     log2_max_mv_length_vertical;
+    StdVideoH265SpsVuiFlags     flags;
+} StdVideoH265SequenceParameterSetVui;
+
+typedef struct StdVideoH265PredictorPaletteEntries
+{
+    uint16_t PredictorPaletteEntries[3][128];
+} StdVideoH265PredictorPaletteEntries;
+
+
+typedef struct StdVideoH265SpsFlags {
+    uint32_t sps_temporal_id_nesting_flag : 1;
+    uint32_t separate_colour_plane_flag : 1;
+    uint32_t scaling_list_enabled_flag : 1;
+    uint32_t sps_scaling_list_data_present_flag : 1;
+    uint32_t amp_enabled_flag : 1;
+    uint32_t sample_adaptive_offset_enabled_flag : 1;
+    uint32_t pcm_enabled_flag : 1;
+    uint32_t pcm_loop_filter_disabled_flag : 1;
+    uint32_t long_term_ref_pics_present_flag : 1;
+    uint32_t sps_temporal_mvp_enabled_flag : 1;
+    uint32_t strong_intra_smoothing_enabled_flag : 1;
+    uint32_t vui_parameters_present_flag : 1;
+    uint32_t sps_extension_present_flag : 1;
+    uint32_t sps_range_extension_flag : 1;
+
+    // extension SPS flags, valid when std_video_h265_profile_idc_format_range_extensions is set
+    uint32_t transform_skip_rotation_enabled_flag : 1;
+    uint32_t transform_skip_context_enabled_flag : 1;
+    uint32_t implicit_rdpcm_enabled_flag : 1;
+    uint32_t explicit_rdpcm_enabled_flag : 1;
+    uint32_t extended_precision_processing_flag : 1;
+    uint32_t intra_smoothing_disabled_flag : 1;
+    uint32_t high_precision_offsets_enabled_flag : 1;
+    uint32_t persistent_rice_adaptation_enabled_flag : 1;
+    uint32_t cabac_bypass_alignment_enabled_flag : 1;
+
+    // extension SPS flags, valid when std_video_h265_profile_idc_scc_extensions is set
+    uint32_t sps_curr_pic_ref_enabled_flag : 1;
+    uint32_t palette_mode_enabled_flag : 1;
+    uint32_t sps_palette_predictor_initializer_present_flag : 1;
+    uint32_t intra_boundary_filtering_disabled_flag : 1;
+} StdVideoH265SpsFlags;
+
+typedef struct StdVideoH265SequenceParameterSet
+{
+    StdVideoH265ProfileIdc               profile_idc;
+    StdVideoH265Level                    level_idc;
+    uint32_t                             pic_width_in_luma_samples;
+    uint32_t                             pic_height_in_luma_samples;
+    uint8_t                              sps_video_parameter_set_id;
+    uint8_t                              sps_max_sub_layers_minus1;
+    uint8_t                              sps_seq_parameter_set_id;
+    uint8_t                              chroma_format_idc;
+    uint8_t                              bit_depth_luma_minus8;
+    uint8_t                              bit_depth_chroma_minus8;
+    uint8_t                              log2_max_pic_order_cnt_lsb_minus4;
+    uint8_t                              sps_max_dec_pic_buffering_minus1;
+    uint8_t                              log2_min_luma_coding_block_size_minus3;
+    uint8_t                              log2_diff_max_min_luma_coding_block_size;
+    uint8_t                              log2_min_luma_transform_block_size_minus2;
+    uint8_t                              log2_diff_max_min_luma_transform_block_size;
+    uint8_t                              max_transform_hierarchy_depth_inter;
+    uint8_t                              max_transform_hierarchy_depth_intra;
+    uint8_t                              num_short_term_ref_pic_sets;
+    uint8_t                              num_long_term_ref_pics_sps;
+    uint8_t                              pcm_sample_bit_depth_luma_minus1;
+    uint8_t                              pcm_sample_bit_depth_chroma_minus1;
+    uint8_t                              log2_min_pcm_luma_coding_block_size_minus3;
+    uint8_t                              log2_diff_max_min_pcm_luma_coding_block_size;
+    uint32_t                             conf_win_left_offset;
+    uint32_t                             conf_win_right_offset;
+    uint32_t                             conf_win_top_offset;
+    uint32_t                             conf_win_bottom_offset;
+    StdVideoH265DecPicBufMgr*            pDecPicBufMgr;
+    StdVideoH265SpsFlags                 flags;
+    StdVideoH265ScalingLists*            pScalingLists;             // Must be a valid pointer if sps_scaling_list_data_present_flag is set
+    StdVideoH265SequenceParameterSetVui* pSequenceParameterSetVui;  // Must be a valid pointer if StdVideoH265SpsFlags:vui_parameters_present_flag is set palette_max_size;
+
+    // extension SPS flags, valid when std_video_h265_profile_idc_scc_extensions is set
+    uint8_t                              palette_max_size;
+    uint8_t                              delta_palette_max_predictor_size;
+    uint8_t                              motion_vector_resolution_control_idc;
+    uint8_t                              sps_num_palette_predictor_initializer_minus1;
+    StdVideoH265PredictorPaletteEntries* pPredictorPaletteEntries;  // Must be a valid pointer if sps_palette_predictor_initializer_present_flag is set
+} StdVideoH265SequenceParameterSet;
+
+
+typedef struct StdVideoH265PpsFlags {
+    uint32_t dependent_slice_segments_enabled_flag : 1;
+    uint32_t output_flag_present_flag : 1;
+    uint32_t sign_data_hiding_enabled_flag : 1;
+    uint32_t cabac_init_present_flag : 1;
+    uint32_t constrained_intra_pred_flag : 1;
+    uint32_t transform_skip_enabled_flag : 1;
+    uint32_t cu_qp_delta_enabled_flag : 1;
+    uint32_t pps_slice_chroma_qp_offsets_present_flag : 1;
+    uint32_t weighted_pred_flag : 1;
+    uint32_t weighted_bipred_flag : 1;
+    uint32_t transquant_bypass_enabled_flag : 1;
+    uint32_t tiles_enabled_flag : 1;
+    uint32_t entropy_coding_sync_enabled_flag : 1;
+    uint32_t uniform_spacing_flag : 1;
+    uint32_t loop_filter_across_tiles_enabled_flag : 1;
+    uint32_t pps_loop_filter_across_slices_enabled_flag : 1;
+    uint32_t deblocking_filter_control_present_flag : 1;
+    uint32_t deblocking_filter_override_enabled_flag : 1;
+    uint32_t pps_deblocking_filter_disabled_flag : 1;
+    uint32_t pps_scaling_list_data_present_flag : 1;
+    uint32_t lists_modification_present_flag : 1;
+    uint32_t slice_segment_header_extension_present_flag : 1;
+    uint32_t pps_extension_present_flag : 1;
+
+    // extension PPS flags, valid when std_video_h265_profile_idc_format_range_extensions is set
+    uint32_t cross_component_prediction_enabled_flag : 1;
+    uint32_t chroma_qp_offset_list_enabled_flag : 1;
+
+    // extension PPS flags, valid when std_video_h265_profile_idc_scc_extensions is set
+    uint32_t pps_curr_pic_ref_enabled_flag : 1;
+    uint32_t residual_adaptive_colour_transform_enabled_flag : 1;
+    uint32_t pps_slice_act_qp_offsets_present_flag : 1;
+    uint32_t pps_palette_predictor_initializer_present_flag : 1;
+    uint32_t monochrome_palette_flag : 1;
+    uint32_t pps_range_extension_flag : 1;
+} StdVideoH265PpsFlags;
+
+typedef struct StdVideoH265PictureParameterSet
+{
+    uint8_t                              pps_pic_parameter_set_id;
+    uint8_t                              pps_seq_parameter_set_id;
+    uint8_t                              num_extra_slice_header_bits;
+    uint8_t                              num_ref_idx_l0_default_active_minus1;
+    uint8_t                              num_ref_idx_l1_default_active_minus1;
+    int8_t                               init_qp_minus26;
+    uint8_t                              diff_cu_qp_delta_depth;
+    int8_t                               pps_cb_qp_offset;
+    int8_t                               pps_cr_qp_offset;
+    uint8_t                              num_tile_columns_minus1;
+    uint8_t                              num_tile_rows_minus1;
+    uint16_t                             column_width_minus1[19];
+    uint16_t                             row_height_minus1[21];
+    int8_t                               pps_beta_offset_div2;
+    int8_t                               pps_tc_offset_div2;
+    uint8_t                              log2_parallel_merge_level_minus2;
+    StdVideoH265PpsFlags                 flags;
+    StdVideoH265ScalingLists*            pScalingLists; // Must be a valid pointer if pps_scaling_list_data_present_flag is set
+
+    // extension PPS, valid when std_video_h265_profile_idc_format_range_extensions is set
+    uint8_t                              log2_max_transform_skip_block_size_minus2;
+    uint8_t                              diff_cu_chroma_qp_offset_depth;
+    uint8_t                              chroma_qp_offset_list_len_minus1;
+    int8_t                               cb_qp_offset_list[6];
+    int8_t                               cr_qp_offset_list[6];
+    uint8_t                              log2_sao_offset_scale_luma;
+    uint8_t                              log2_sao_offset_scale_chroma;
+
+    // extension PPS, valid when std_video_h265_profile_idc_scc_extensions is set
+    int8_t                               pps_act_y_qp_offset_plus5;
+    int8_t                               pps_act_cb_qp_offset_plus5;
+    int8_t                               pps_act_cr_qp_offset_plus5;
+    uint8_t                              pps_num_palette_predictor_initializer;
+    uint8_t                              luma_bit_depth_entry_minus8;
+    uint8_t                              chroma_bit_depth_entry_minus8;
+    StdVideoH265PredictorPaletteEntries* pPredictorPaletteEntries;  // Must be a valid pointer if pps_palette_predictor_initializer_present_flag is set
+} StdVideoH265PictureParameterSet;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif // VULKAN_VIDEO_CODEC_H265STD_H_
diff --git a/include/vk_video/vulkan_video_codec_h265std_decode.h b/include/vk_video/vulkan_video_codec_h265std_decode.h
new file mode 100644
index 0000000..4be8b5f
--- /dev/null
+++ b/include/vk_video/vulkan_video_codec_h265std_decode.h
@@ -0,0 +1,59 @@
+/*
+** Copyright (c) 2019-2021 The Khronos Group Inc.
+**
+** SPDX-License-Identifier: Apache-2.0
+*/
+
+#ifndef VULKAN_VIDEO_CODEC_H265STD_DECODE_H_
+#define VULKAN_VIDEO_CODEC_H265STD_DECODE_H_ 1
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "vk_video/vulkan_video_codec_h265std.h"
+
+// *************************************************
+// Video h265 Decode related parameters:
+// *************************************************
+
+typedef struct StdVideoDecodeH265PictureInfoFlags {
+    uint32_t IrapPicFlag : 1;
+    uint32_t IdrPicFlag  : 1;
+    uint32_t IsReference : 1;
+    uint32_t short_term_ref_pic_set_sps_flag : 1;
+} StdVideoDecodeH265PictureInfoFlags;
+
+typedef struct StdVideoDecodeH265PictureInfo {
+    uint8_t                            vps_video_parameter_set_id;
+    uint8_t                            sps_seq_parameter_set_id;
+    uint8_t                            pps_pic_parameter_set_id;
+    uint8_t                            num_short_term_ref_pic_sets;
+    int32_t                            PicOrderCntVal;
+    uint16_t                           NumBitsForSTRefPicSetInSlice; // number of bits used in st_ref_pic_set()
+                                                                     //when short_term_ref_pic_set_sps_flag is 0; otherwise set to 0.
+    uint8_t                            NumDeltaPocsOfRefRpsIdx;      // NumDeltaPocs[ RefRpsIdx ] when short_term_ref_pic_set_sps_flag = 1, otherwise 0
+    uint8_t                            RefPicSetStCurrBefore[8];     // slotIndex as used in VkVideoReferenceSlotKHR structures representing
+                                                                     //pReferenceSlots in VkVideoDecodeInfoKHR, 0xff for invalid slotIndex
+    uint8_t                            RefPicSetStCurrAfter[8];      // slotIndex as used in VkVideoReferenceSlotKHR structures representing
+                                                                     //pReferenceSlots in VkVideoDecodeInfoKHR, 0xff for invalid slotIndex
+    uint8_t                            RefPicSetLtCurr[8];           // slotIndex as used in VkVideoReferenceSlotKHR structures representing
+                                                                     //pReferenceSlots in VkVideoDecodeInfoKHR, 0xff for invalid slotIndex
+    StdVideoDecodeH265PictureInfoFlags flags;
+} StdVideoDecodeH265PictureInfo;
+
+typedef struct StdVideoDecodeH265ReferenceInfoFlags {
+    uint32_t is_long_term : 1;
+    uint32_t is_non_existing : 1;
+} StdVideoDecodeH265ReferenceInfoFlags;
+
+typedef struct StdVideoDecodeH265ReferenceInfo {
+    int32_t                              PicOrderCntVal;
+    StdVideoDecodeH265ReferenceInfoFlags flags;
+} StdVideoDecodeH265ReferenceInfo;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif // VULKAN_VIDEO_CODEC_H265STD_DECODE_H_
diff --git a/include/vk_video/vulkan_video_codecs_common.h b/include/vk_video/vulkan_video_codecs_common.h
new file mode 100644
index 0000000..8cc227a
--- /dev/null
+++ b/include/vk_video/vulkan_video_codecs_common.h
@@ -0,0 +1,21 @@
+/*
+** Copyright (c) 2019-2021 The Khronos Group Inc.
+**
+** SPDX-License-Identifier: Apache-2.0
+*/
+
+#ifndef VULKAN_VIDEO_CODEC_COMMON_H_
+#define VULKAN_VIDEO_CODEC_COMMON_H_ 1
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define VK_MAKE_VIDEO_STD_VERSION(major, minor, patch) \
+    ((((uint32_t)(major)) << 22) | (((uint32_t)(minor)) << 12) | ((uint32_t)(patch)))
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif // VULKAN_VIDEO_CODEC_COMMON_H_
diff --git a/ios-aarch64 b/ios-aarch64
new file mode 100644
index 0000000..4f321eb
--- /dev/null
+++ b/ios-aarch64
@@ -0,0 +1,19 @@
+[binaries]
+
+ar = 'ar'
+c = ['ccache', 'clang', '-O3', '-DVK_USE_PLATFORM_IOS_MVK', '-DVK_USE_PLATFORM_METAL_EXT', '-DVK_ENABLE_BETA_EXTENSIONS', '-arch', 'arm64', '-isysroot', '/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk', '-miphoneos-version-min=12.0', '-fPIC']
+cpp = ['ccache', 'clang++', '-O3', '-DVK_USE_PLATFORM_IOS_MVK', '-DVK_USE_PLATFORM_METAL_EXT', '-DVK_ENABLE_BETA_EXTENSIONS', '-arch', 'arm64', '-isysroot', '/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk', '-miphoneos-version-min=12.0', '-fPIC', '-fno-exceptions', '-fno-unwind-tables', '-fno-asynchronous-unwind-tables', '-static-libstdc++']
+c_ld = 'ld'
+cpp_ld = 'ld'
+strip = 'strip'
+# Android doesn't come with a pkg-config, but we need one for meson to be happy not
+# finding all the optional deps it looks for.  Use system pkg-config pointing at a
+# directory we get to populate with any .pc files we want to add for Android
+pkgconfig = ['env', 'PKG_CONFIG_LIBDIR=/Users/runner/work/mesa/mesa', 'pkg-config']
+
+[host_machine]
+# or linux?
+system = 'darwin'
+cpu_family = 'arm'
+cpu = 'armv8'
+endian = 'little'
diff --git a/log.pc b/log.pc
new file mode 100644
index 0000000..235f45c
--- /dev/null
+++ b/log.pc
@@ -0,0 +1,4 @@
+Name: log
+Description: Android liblog library
+Version: 1.0
+Libs: -llog
diff --git a/meson.build b/meson.build
index 155db28..f3192b9 100644
--- a/meson.build
+++ b/meson.build
@@ -323,7 +323,8 @@ with_clc = dep_clang.found()
 with_spirv_to_dxil = get_option('spirv-to-dxil')
 
 if host_machine.system() == 'darwin'
-  with_dri_platform = 'apple'
+  # with_dri_platform = 'apple'
+  with_dri_platform = 'none'
   pre_args += '-DBUILDING_MESA'
 elif ['windows', 'cygwin'].contains(host_machine.system())
   with_dri_platform = 'windows'
@@ -489,9 +490,9 @@ if (not ['freebsd', 'openbsd', 'haiku'].contains(host_machine.system()) and
   endif
 endif
 
-if with_glx != 'disabled'
+if with_glx != 'disabled' and host_machine.system() != 'darwin'
   if not (with_platform_x11 and with_any_opengl)
-    error('Cannot build GLX support without X11 platform support and at least one OpenGL API')
+    warning('Cannot build GLX support without X11 platform support and at least one OpenGL API')
   elif with_glx == 'gallium-xlib'
     if not with_gallium
       error('Gallium-xlib based GLX requires at least one gallium driver')
@@ -1565,7 +1566,7 @@ with_gallium_drisw_kms = false
 dep_libdrm = dependency(
   'libdrm', version : '>=' + _drm_ver,
   # GNU/Hurd includes egl_dri2, without drm.
-  required : (with_dri2 and host_machine.system() != 'gnu') or with_dri3
+  required : not with_platform_android and ((with_dri2 and host_machine.system() != 'gnu') or with_dri3)
 )
 if dep_libdrm.found()
   pre_args += '-DHAVE_LIBDRM'
@@ -1875,7 +1876,7 @@ endif
 
 if with_osmesa
   if not with_gallium_softpipe
-    error('OSMesa gallium requires gallium softpipe or llvmpipe.')
+    warning('OSMesa gallium requires gallium softpipe or llvmpipe.')
   endif
   if host_machine.system() == 'windows'
     osmesa_lib_name = 'osmesa'
@@ -1947,7 +1948,7 @@ if host_machine.cpu_family() == 'x86_64' and cc.get_id() == 'gcc'
   endif
 endif
 
-if with_platform_x11
+if with_platform_x11 and host_machine.system() != 'darwin'
   if with_glx == 'xlib' or with_glx == 'gallium-xlib'
     dep_x11 = dependency('x11')
     dep_xext = dependency('xext')
diff --git a/meson_options.txt b/meson_options.txt
index 29c402c..5e29e1d 100644
--- a/meson_options.txt
+++ b/meson_options.txt
@@ -481,7 +481,7 @@ option(
 option(
   'platform-sdk-version',
   type : 'integer',
-  min : 25,
+  min : 24,
   max : 30,
   value : 25,
   description : 'Android Platform SDK version. Default: Nougat version.'
diff --git a/nativewindow.pc b/nativewindow.pc
new file mode 100644
index 0000000..cfe23c0
--- /dev/null
+++ b/nativewindow.pc
@@ -0,0 +1,4 @@
+Name: nativewindow
+Description: Android libnativewindow library
+Version: 1.0
+Libs:
diff --git a/src/android_stub/meson.build b/src/android_stub/meson.build
index 86f88ca..cfa810e 100644
--- a/src/android_stub/meson.build
+++ b/src/android_stub/meson.build
@@ -1,7 +1,16 @@
 if with_android_stub
   stub_libs = []
 
-  foreach lib : ['backtrace', 'cutils', 'hardware', 'log', 'nativewindow', 'sync']
+  foreach lib : ['backtrace', 'cutils']
+    stub_libs += static_library(
+      lib,
+      files(lib + '_stub.cpp'),
+      include_directories : inc_include,
+      install : false,
+    )
+  endforeach
+
+  foreach lib : ['hardware']
     stub_libs += shared_library(
       lib,
       files(lib + '_stub.cpp'),
@@ -12,5 +21,10 @@ if with_android_stub
 
   dep_android = declare_dependency(
     link_with : stub_libs,
+    dependencies : [
+      dependency('log'),
+      dependency('sync'),
+      dependency('nativewindow'),
+    ]
   )
 endif
diff --git a/src/gallium/auxiliary/target-helpers/inline_sw_helper.h b/src/gallium/auxiliary/target-helpers/inline_sw_helper.h
index 4fb7499..6426b6f 100644
--- a/src/gallium/auxiliary/target-helpers/inline_sw_helper.h
+++ b/src/gallium/auxiliary/target-helpers/inline_sw_helper.h
@@ -37,6 +37,10 @@
 #include "asahi/agx_public.h"
 #endif
 
+#ifdef GALLIUM_ZINK
+struct pipe_screen *zink_create_screen(struct sw_winsys *winsys);
+#endif
+
 static inline struct pipe_screen *
 sw_screen_create_named(struct sw_winsys *winsys, const char *driver)
 {
diff --git a/src/gallium/drivers/virgl/virgl_screen.c b/src/gallium/drivers/virgl/virgl_screen.c
index 2b3f5ed..8a67cda 100644
--- a/src/gallium/drivers/virgl/virgl_screen.c
+++ b/src/gallium/drivers/virgl/virgl_screen.c
@@ -898,17 +898,23 @@ static struct disk_cache *virgl_get_disk_shader_cache (struct pipe_screen *pscre
 
 static void virgl_disk_cache_create(struct virgl_screen *screen)
 {
-   const struct build_id_note *note =
-      build_id_find_nhdr_for_addr(virgl_disk_cache_create);
-   assert(note && build_id_length(note) == 20); /* sha1 */
-
-   const uint8_t *id_sha1 = build_id_data(note);
-   assert(id_sha1);
-
-   char timestamp[41];
-   _mesa_sha1_format(timestamp, id_sha1);
-
-   screen->disk_cache = disk_cache_create("virgl", timestamp, 0);
+//#ifndef __APPLE__
+//   const struct build_id_note *note =
+//      build_id_find_nhdr_for_addr(virgl_disk_cache_create);
+//   assert(note && build_id_length(note) == 20); /* sha1 */
+//
+//   const uint8_t *id_sha1 = build_id_data(note);
+//   assert(id_sha1);
+//
+//   char timestamp[41];
+//   _mesa_sha1_format(timestamp, id_sha1);
+//
+//   screen->disk_cache = disk_cache_create("virgl", timestamp, 0);
+//#else
+//   screen->disk_cache = disk_cache_create("virgl", "??? (build_id unimplemented)", 0);
+//#endif
+
+   screen->disk_cache = disk_cache_create("virgl", "unknown", 0);
 }
 
 static void
diff --git a/src/gallium/drivers/zink/zink_screen.c b/src/gallium/drivers/zink/zink_screen.c
index 8d1a4ed..23bfffe 100644
--- a/src/gallium/drivers/zink/zink_screen.c
+++ b/src/gallium/drivers/zink/zink_screen.c
@@ -1830,8 +1830,10 @@ zink_internal_create_screen(const struct pipe_screen_config *config)
    zink_internal_setup_moltenvk(screen);
 
    screen->dev = zink_create_logical_device(screen);
-   if (!screen->dev)
+   if (!screen->dev) {
+      debug_printf("ZINK: failed to init: no logical device\n");
       goto fail;
+   }
 
    init_queue(screen);
    if (screen->info.driver_props.driverID == VK_DRIVER_ID_MESA_RADV ||
diff --git a/src/gallium/frontends/dri/meson.build b/src/gallium/frontends/dri/meson.build
index 36c9ba0..8fd1dc1 100644
--- a/src/gallium/frontends/dri/meson.build
+++ b/src/gallium/frontends/dri/meson.build
@@ -48,7 +48,7 @@ endif
 
 libdri = static_library(
   'dri',
-  files_libdri,
+  with_platform_android ? [] : files_libdri,
   include_directories : [
     inc_include, inc_util, inc_mesa, inc_mapi, inc_src, inc_gallium,
     inc_gallium_aux, inc_dri_common,
diff --git a/src/gallium/frontends/osmesa/meson.build b/src/gallium/frontends/osmesa/meson.build
index e5848fd..3f85942 100644
--- a/src/gallium/frontends/osmesa/meson.build
+++ b/src/gallium/frontends/osmesa/meson.build
@@ -28,7 +28,7 @@ endif
 
 libosmesa_st = static_library(
   'osmesa_st',
-  'osmesa.c',
+  'osmesa_bufferless.c',
   c_args : osmesa_st_c_args,
   include_directories : [
     inc_include, inc_src, inc_gallium, inc_gallium_aux, inc_mapi, inc_mesa,
diff --git a/src/gallium/frontends/osmesa/osmesa.c b/src/gallium/frontends/osmesa/osmesa.c
index 9638889..ed9a597 100644
--- a/src/gallium/frontends/osmesa/osmesa.c
+++ b/src/gallium/frontends/osmesa/osmesa.c
@@ -162,6 +162,7 @@ create_st_manager(void)
    }
 
    stapi = st_gl_api_create();
+   debug_printf("OSMESA: stmgr=%p; stapi=%p\n",stmgr,stapi);
 }
 
 /**
@@ -701,6 +702,31 @@ OSMesaCreateContextAttribs(const int *attribList, OSMesaContext sharelist)
    osmesa->stctx = stapi->create_context(stapi, get_st_manager(),
                                          &attribs, &st_error, st_shared);
    if (!osmesa->stctx) {
+      char* st_error_str;
+      switch (st_error) {
+         case ST_CONTEXT_ERROR_NO_MEMORY:
+            st_error_str="ST_CONTEXT_ERROR_NO_MEMORY";
+            break;
+         case ST_CONTEXT_ERROR_BAD_API:
+            st_error_str="ST_CONTEXT_ERROR_BAD_API";
+            break;
+         case ST_CONTEXT_ERROR_BAD_VERSION:
+            st_error_str="ST_CONTEXT_ERROR_BAD_VERSION";
+            break;
+         case ST_CONTEXT_ERROR_BAD_FLAG:
+            st_error_str="ST_CONTEXT_ERROR_BAD_FLAG";
+            break;
+         case ST_CONTEXT_ERROR_UNKNOWN_ATTRIBUTE:
+            st_error_str="ST_CONTEXT_ERROR_UNKNOWN_ATTRIBUTE";
+            break;
+         case ST_CONTEXT_ERROR_UNKNOWN_FLAG:
+            st_error_str="ST_CONTEXT_ERROR_UNKNOWN_FLAG";
+            break;
+         default:
+            st_error_str="UNKNOWN";
+            break;
+      }
+      debug_printf("OSMESA: error: unable to create st context, st_error=%s",st_error_str);
       FREE(osmesa);
       return NULL;
    }
diff --git a/src/gallium/frontends/osmesa/osmesa_bufferless.c b/src/gallium/frontends/osmesa/osmesa_bufferless.c
new file mode 100644
index 0000000..56684ff
--- /dev/null
+++ b/src/gallium/frontends/osmesa/osmesa_bufferless.c
@@ -0,0 +1,1074 @@
+/*
+ * Copyright (c) 2013  Brian Paul   All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+
+/*
+ * Off-Screen rendering into client memory.
+ * OpenGL gallium frontend for softpipe and llvmpipe.
+ *
+ * Notes:
+ *
+ * If Gallium is built with LLVM support we use the llvmpipe driver.
+ * Otherwise we use softpipe.  The GALLIUM_DRIVER environment variable
+ * may be set to "softpipe" or "llvmpipe" to override.
+ *
+ * With softpipe we could render directly into the user's buffer by using a
+ * display target resource.  However, softpipe doesn't support "upside-down"
+ * rendering which would be needed for the OSMESA_Y_UP=TRUE case.
+ *
+ * With llvmpipe we could only render directly into the user's buffer when its
+ * width and height is a multiple of the tile size (64 pixels).
+ *
+ * Because of these constraints we always render into ordinary resources then
+ * copy the results to the user's buffer in the flush_front() function which
+ * is called when the app calls glFlush/Finish.
+ *
+ * In general, the OSMesa interface is pretty ugly and not a good match
+ * for Gallium.  But we're interested in doing the best we can to preserve
+ * application portability.  With a little work we could come up with a
+ * much nicer, new off-screen Gallium interface...
+ */
+
+
+#include <stdio.h>
+#include <c11/threads.h>
+#include "GL/osmesa.h"
+
+#include "glapi/glapi.h"  /* for OSMesaGetProcAddress below */
+
+#include "pipe/p_context.h"
+#include "pipe/p_screen.h"
+#include "pipe/p_state.h"
+
+#include "util/u_atomic.h"
+#include "util/u_box.h"
+#include "util/u_debug.h"
+#include "util/format/u_format.h"
+#include "util/u_inlines.h"
+#include "util/u_memory.h"
+
+#include "postprocess/filters.h"
+#include "postprocess/postprocess.h"
+
+#include "frontend/api.h"
+#include "state_tracker/st_gl_api.h"
+
+
+
+extern struct pipe_screen *
+osmesa_create_screen(void);
+
+
+
+struct osmesa_buffer
+{
+   struct st_framebuffer_iface *stfb;
+   struct st_visual visual;
+   unsigned width, height;
+
+   struct pipe_resource *textures[ST_ATTACHMENT_COUNT];
+
+   void *map;
+
+   struct osmesa_buffer *next;  /**< next in linked list */
+};
+
+
+struct osmesa_context
+{
+   struct st_context_iface *stctx;
+
+   boolean ever_used;     /*< Has this context ever been current? */
+
+   struct osmesa_buffer *current_buffer;
+
+   /* Storage for depth/stencil, if the user has requested access.  The backing
+    * driver always has its own storage for the actual depth/stencil, which we
+    * have to transfer in and out.
+    */
+   void *zs;
+   unsigned zs_stride;
+
+   enum pipe_format depth_stencil_format, accum_format;
+
+   GLenum format;         /*< User-specified context format */
+   GLenum type;           /*< Buffer's data type */
+   GLint user_row_length; /*< user-specified number of pixels per row */
+   GLboolean y_up;        /*< TRUE  -> Y increases upward */
+                          /*< FALSE -> Y increases downward */
+
+   /** Which postprocessing filters are enabled. */
+   unsigned pp_enabled[PP_FILTERS];
+   struct pp_queue_t *pp;
+};
+
+/**
+ * Called from the ST manager.
+ */
+static int
+osmesa_st_get_param(struct st_manager *smapi, enum st_manager_param param)
+{
+   /* no-op */
+   return 0;
+}
+
+static struct st_manager *stmgr = NULL;
+static struct st_api *stapi = NULL;
+
+static void
+destroy_st_manager(void)
+{
+   if (stmgr) {
+      if (stmgr->screen)
+         stmgr->screen->destroy(stmgr->screen);
+      FREE(stmgr);
+   }
+
+   if (stapi && stapi->destroy) {
+      stapi->destroy(stapi);
+   }
+}
+
+static void
+create_st_manager(void)
+{
+   if (atexit(destroy_st_manager) != 0)
+      return;
+
+   stmgr = CALLOC_STRUCT(st_manager);
+   if (stmgr) {
+      stmgr->screen = osmesa_create_screen();
+      stmgr->get_param = osmesa_st_get_param;
+      stmgr->get_egl_image = NULL;
+   }
+
+   stapi = st_gl_api_create();
+   debug_printf("OSMESA: stmgr=%p; stapi=%p\n",stmgr,stapi);
+}
+
+/**
+ * Create/return a singleton st_manager object.
+ */
+static struct st_manager *
+get_st_manager(void)
+{
+   static once_flag create_once_flag = ONCE_FLAG_INIT;
+
+   call_once(&create_once_flag, create_st_manager);
+
+   return stmgr;
+}
+
+/**
+ * Create/return singleton st_api object.
+ */
+static struct st_api *
+get_st_api(void)
+{
+   get_st_manager();
+   return stapi;
+}
+
+/* Reads the color or depth buffer from the backing context to either the user storage
+ * (color buffer) or our temporary (z/s)
+ */
+static void
+osmesa_read_buffer(OSMesaContext osmesa, struct pipe_resource *res, void *dst,
+                   int dst_stride, bool y_up)
+{
+   struct pipe_context *pipe = osmesa->stctx->pipe;
+
+   struct pipe_box box;
+   u_box_2d(0, 0, res->width0, res->height0, &box);
+
+   struct pipe_transfer *transfer = NULL;
+   ubyte *src = pipe->texture_map(pipe, res, 0, PIPE_MAP_READ, &box,
+                                   &transfer);
+
+   /*
+    * Copy the color buffer from the resource to the user's buffer.
+    */
+
+   if (y_up) {
+      /* need to flip image upside down */
+      dst = (ubyte *)dst + (res->height0 - 1) * dst_stride;
+      dst_stride = -dst_stride;
+   }
+
+   unsigned bpp = util_format_get_blocksize(res->format);
+   for (unsigned y = 0; y < res->height0; y++)
+   {
+      memcpy(dst, src, bpp * res->width0);
+      dst = (ubyte *)dst + dst_stride;
+      src += transfer->stride;
+   }
+
+   pipe->texture_unmap(pipe, transfer);
+}
+
+
+/**
+ * Given an OSMESA_x format and a GL_y type, return the best
+ * matching PIPE_FORMAT_z.
+ * Note that we can't exactly match all user format/type combinations
+ * with gallium formats.  If we find this to be a problem, we can
+ * implement more elaborate format/type conversion in the flush_front()
+ * function.
+ */
+static enum pipe_format
+osmesa_choose_format(GLenum format, GLenum type)
+{
+   switch (format) {
+   case OSMESA_RGBA:
+      if (type == GL_UNSIGNED_BYTE) {
+#if UTIL_ARCH_LITTLE_ENDIAN
+         return PIPE_FORMAT_R8G8B8A8_UNORM;
+#else
+         return PIPE_FORMAT_A8B8G8R8_UNORM;
+#endif
+      }
+      else if (type == GL_UNSIGNED_SHORT) {
+         return PIPE_FORMAT_R16G16B16A16_UNORM;
+      }
+      else if (type == GL_FLOAT) {
+         return PIPE_FORMAT_R32G32B32A32_FLOAT;
+      }
+      else {
+         return PIPE_FORMAT_NONE;
+      }
+      break;
+   case OSMESA_BGRA:
+      if (type == GL_UNSIGNED_BYTE) {
+#if UTIL_ARCH_LITTLE_ENDIAN
+         return PIPE_FORMAT_B8G8R8A8_UNORM;
+#else
+         return PIPE_FORMAT_A8R8G8B8_UNORM;
+#endif
+      }
+      else if (type == GL_UNSIGNED_SHORT) {
+         return PIPE_FORMAT_R16G16B16A16_UNORM;
+      }
+      else if (type == GL_FLOAT) {
+         return PIPE_FORMAT_R32G32B32A32_FLOAT;
+      }
+      else {
+         return PIPE_FORMAT_NONE;
+      }
+      break;
+   case OSMESA_ARGB:
+      if (type == GL_UNSIGNED_BYTE) {
+#if UTIL_ARCH_LITTLE_ENDIAN
+         return PIPE_FORMAT_A8R8G8B8_UNORM;
+#else
+         return PIPE_FORMAT_B8G8R8A8_UNORM;
+#endif
+      }
+      else if (type == GL_UNSIGNED_SHORT) {
+         return PIPE_FORMAT_R16G16B16A16_UNORM;
+      }
+      else if (type == GL_FLOAT) {
+         return PIPE_FORMAT_R32G32B32A32_FLOAT;
+      }
+      else {
+         return PIPE_FORMAT_NONE;
+      }
+      break;
+   case OSMESA_RGB:
+      if (type == GL_UNSIGNED_BYTE) {
+         return PIPE_FORMAT_R8G8B8_UNORM;
+      }
+      else if (type == GL_UNSIGNED_SHORT) {
+         return PIPE_FORMAT_R16G16B16_UNORM;
+      }
+      else if (type == GL_FLOAT) {
+         return PIPE_FORMAT_R32G32B32_FLOAT;
+      }
+      else {
+         return PIPE_FORMAT_NONE;
+      }
+      break;
+   case OSMESA_BGR:
+      /* No gallium format for this one */
+      return PIPE_FORMAT_NONE;
+   case OSMESA_RGB_565:
+      if (type != GL_UNSIGNED_SHORT_5_6_5)
+         return PIPE_FORMAT_NONE;
+      return PIPE_FORMAT_B5G6R5_UNORM;
+   default:
+      return PIPE_FORMAT_NONE;
+   }
+}
+
+
+/**
+ * Initialize an st_visual object.
+ */
+static void
+osmesa_init_st_visual(struct st_visual *vis,
+                      enum pipe_format color_format,
+                      enum pipe_format ds_format,
+                      enum pipe_format accum_format)
+{
+   vis->buffer_mask = ST_ATTACHMENT_FRONT_LEFT_MASK;
+
+   if (ds_format != PIPE_FORMAT_NONE)
+      vis->buffer_mask |= ST_ATTACHMENT_DEPTH_STENCIL_MASK;
+   if (accum_format != PIPE_FORMAT_NONE)
+      vis->buffer_mask |= ST_ATTACHMENT_ACCUM;
+
+   vis->color_format = color_format;
+   vis->depth_stencil_format = ds_format;
+   vis->accum_format = accum_format;
+   vis->samples = 1;
+}
+
+
+/**
+ * Return the osmesa_buffer that corresponds to an st_framebuffer_iface.
+ */
+static inline struct osmesa_buffer *
+stfbi_to_osbuffer(struct st_framebuffer_iface *stfbi)
+{
+   return (struct osmesa_buffer *) stfbi->st_manager_private;
+}
+
+
+/**
+ * Called via glFlush/glFinish.  This is where we copy the contents
+ * of the driver's color buffer into the user-specified buffer.
+ */
+static bool
+osmesa_st_framebuffer_flush_front(struct st_context_iface *stctx,
+                                  struct st_framebuffer_iface *stfbi,
+                                  enum st_attachment_type statt)
+{
+   OSMesaContext osmesa = OSMesaGetCurrentContext();
+   struct osmesa_buffer *osbuffer = stfbi_to_osbuffer(stfbi);
+   struct pipe_resource *res = osbuffer->textures[statt];
+   unsigned bpp;
+   int dst_stride;
+
+   if (statt != ST_ATTACHMENT_FRONT_LEFT)
+      return false;
+
+   if (osmesa->pp) {
+      struct pipe_resource *zsbuf = NULL;
+      unsigned i;
+
+      /* Find the z/stencil buffer if there is one */
+      for (i = 0; i < ARRAY_SIZE(osbuffer->textures); i++) {
+         struct pipe_resource *res = osbuffer->textures[i];
+         if (res) {
+            const struct util_format_description *desc =
+               util_format_description(res->format);
+
+            if (util_format_has_depth(desc)) {
+               zsbuf = res;
+               break;
+            }
+         }
+      }
+
+      /* run the postprocess stage(s) */
+      pp_run(osmesa->pp, res, res, zsbuf);
+   }
+
+   /* Snapshot the color buffer to the user's buffer. */
+   bpp = util_format_get_blocksize(osbuffer->visual.color_format);
+   if (osmesa->user_row_length)
+      dst_stride = bpp * osmesa->user_row_length;
+   else
+      dst_stride = bpp * osbuffer->width;
+
+//   osmesa_read_buffer(osmesa, res, osbuffer->map, dst_stride, osmesa->y_up);
+
+   /* If the user has requested the Z/S buffer, then snapshot that one too. */
+//   if (osmesa->zs) {
+//      osmesa_read_buffer(osmesa, osbuffer->textures[ST_ATTACHMENT_DEPTH_STENCIL],
+//                         osmesa->zs, osmesa->zs_stride, true);
+//   }
+
+   return true;
+}
+
+
+/**
+ * Called by the st manager to validate the framebuffer (allocate
+ * its resources).
+ */
+static bool
+osmesa_st_framebuffer_validate(struct st_context_iface *stctx,
+                               struct st_framebuffer_iface *stfbi,
+                               const enum st_attachment_type *statts,
+                               unsigned count,
+                               struct pipe_resource **out)
+{
+   struct pipe_screen *screen = get_st_manager()->screen;
+   enum st_attachment_type i;
+   struct osmesa_buffer *osbuffer = stfbi_to_osbuffer(stfbi);
+   struct pipe_resource templat;
+
+   memset(&templat, 0, sizeof(templat));
+   templat.target = PIPE_TEXTURE_RECT;
+   templat.format = 0; /* setup below */
+   templat.last_level = 0;
+   templat.width0 = osbuffer->width;
+   templat.height0 = osbuffer->height;
+   templat.depth0 = 1;
+   templat.array_size = 1;
+   templat.usage = PIPE_USAGE_DEFAULT;
+   templat.bind = 0; /* setup below */
+   templat.flags = 0;
+
+   for (i = 0; i < count; i++) {
+      enum pipe_format format = PIPE_FORMAT_NONE;
+      unsigned bind = 0;
+
+      /*
+       * At this time, we really only need to handle the front-left color
+       * attachment, since that's all we specified for the visual in
+       * osmesa_init_st_visual().
+       */
+      if (statts[i] == ST_ATTACHMENT_FRONT_LEFT) {
+         format = osbuffer->visual.color_format;
+         bind = PIPE_BIND_RENDER_TARGET;
+      }
+      else if (statts[i] == ST_ATTACHMENT_DEPTH_STENCIL) {
+         format = osbuffer->visual.depth_stencil_format;
+         bind = PIPE_BIND_DEPTH_STENCIL;
+      }
+      else if (statts[i] == ST_ATTACHMENT_ACCUM) {
+         format = osbuffer->visual.accum_format;
+         bind = PIPE_BIND_RENDER_TARGET;
+      }
+      else {
+         debug_warning("Unexpected attachment type in "
+                       "osmesa_st_framebuffer_validate()");
+      }
+
+      templat.format = format;
+      templat.bind = bind;
+      pipe_resource_reference(&out[i], NULL);
+      out[i] = osbuffer->textures[statts[i]] =
+         screen->resource_create(screen, &templat);
+   }
+
+   return true;
+}
+
+static uint32_t osmesa_fb_ID = 0;
+
+static struct st_framebuffer_iface *
+osmesa_create_st_framebuffer(void)
+{
+   struct st_framebuffer_iface *stfbi = CALLOC_STRUCT(st_framebuffer_iface);
+   if (stfbi) {
+      stfbi->flush_front = osmesa_st_framebuffer_flush_front;
+      stfbi->validate = osmesa_st_framebuffer_validate;
+      p_atomic_set(&stfbi->stamp, 1);
+      stfbi->ID = p_atomic_inc_return(&osmesa_fb_ID);
+      stfbi->state_manager = get_st_manager();
+   }
+   return stfbi;
+}
+
+
+/**
+ * Create new buffer and add to linked list.
+ */
+static struct osmesa_buffer *
+osmesa_create_buffer(enum pipe_format color_format,
+                     enum pipe_format ds_format,
+                     enum pipe_format accum_format)
+{
+   struct osmesa_buffer *osbuffer = CALLOC_STRUCT(osmesa_buffer);
+   if (osbuffer) {
+      osbuffer->stfb = osmesa_create_st_framebuffer();
+
+      osbuffer->stfb->st_manager_private = osbuffer;
+      osbuffer->stfb->visual = &osbuffer->visual;
+
+      osmesa_init_st_visual(&osbuffer->visual, color_format,
+                            ds_format, accum_format);
+   }
+
+   return osbuffer;
+}
+
+
+static void
+osmesa_destroy_buffer(struct osmesa_buffer *osbuffer)
+{
+   /*
+    * Notify the state manager that the associated framebuffer interface
+    * is no longer valid.
+    */
+   stapi->destroy_drawable(stapi, osbuffer->stfb);
+
+   FREE(osbuffer->stfb);
+   FREE(osbuffer);
+}
+
+
+
+/**********************************************************************/
+/*****                    Public Functions                        *****/
+/**********************************************************************/
+
+
+/**
+ * Create an Off-Screen Mesa rendering context.  The only attribute needed is
+ * an RGBA vs Color-Index mode flag.
+ *
+ * Input:  format - Must be GL_RGBA
+ *         sharelist - specifies another OSMesaContext with which to share
+ *                     display lists.  NULL indicates no sharing.
+ * Return:  an OSMesaContext or 0 if error
+ */
+GLAPI OSMesaContext GLAPIENTRY
+OSMesaCreateContext(GLenum format, OSMesaContext sharelist)
+{
+   return OSMesaCreateContextExt(format, 24, 8, 0, sharelist);
+}
+
+
+/**
+ * New in Mesa 3.5
+ *
+ * Create context and specify size of ancillary buffers.
+ */
+GLAPI OSMesaContext GLAPIENTRY
+OSMesaCreateContextExt(GLenum format, GLint depthBits, GLint stencilBits,
+                       GLint accumBits, OSMesaContext sharelist)
+{
+   int attribs[100], n = 0;
+
+   attribs[n++] = OSMESA_FORMAT;
+   attribs[n++] = format;
+   attribs[n++] = OSMESA_DEPTH_BITS;
+   attribs[n++] = depthBits;
+   attribs[n++] = OSMESA_STENCIL_BITS;
+   attribs[n++] = stencilBits;
+   attribs[n++] = OSMESA_ACCUM_BITS;
+   attribs[n++] = accumBits;
+   attribs[n++] = 0;
+
+   return OSMesaCreateContextAttribs(attribs, sharelist);
+}
+
+
+/**
+ * New in Mesa 11.2
+ *
+ * Create context with attribute list.
+ */
+GLAPI OSMesaContext GLAPIENTRY
+OSMesaCreateContextAttribs(const int *attribList, OSMesaContext sharelist)
+{
+   OSMesaContext osmesa;
+   struct st_context_iface *st_shared;
+   enum st_context_error st_error = 0;
+   struct st_context_attribs attribs;
+   struct st_api *stapi = get_st_api();
+   GLenum format = GL_RGBA;
+   int depthBits = 0, stencilBits = 0, accumBits = 0;
+   int profile = OSMESA_COMPAT_PROFILE, version_major = 1, version_minor = 0;
+   int i;
+
+   if (sharelist) {
+      st_shared = sharelist->stctx;
+   }
+   else {
+      st_shared = NULL;
+   }
+
+   for (i = 0; attribList[i]; i += 2) {
+      switch (attribList[i]) {
+      case OSMESA_FORMAT:
+         format = attribList[i+1];
+         switch (format) {
+         case OSMESA_COLOR_INDEX:
+         case OSMESA_RGBA:
+         case OSMESA_BGRA:
+         case OSMESA_ARGB:
+         case OSMESA_RGB:
+         case OSMESA_BGR:
+         case OSMESA_RGB_565:
+            /* legal */
+            break;
+         default:
+            return NULL;
+         }
+         break;
+      case OSMESA_DEPTH_BITS:
+         depthBits = attribList[i+1];
+         if (depthBits < 0)
+            return NULL;
+         break;
+      case OSMESA_STENCIL_BITS:
+         stencilBits = attribList[i+1];
+         if (stencilBits < 0)
+            return NULL;
+         break;
+      case OSMESA_ACCUM_BITS:
+         accumBits = attribList[i+1];
+         if (accumBits < 0)
+            return NULL;
+         break;
+      case OSMESA_PROFILE:
+         profile = attribList[i+1];
+         if (profile != OSMESA_CORE_PROFILE &&
+             profile != OSMESA_COMPAT_PROFILE)
+            return NULL;
+         break;
+      case OSMESA_CONTEXT_MAJOR_VERSION:
+         version_major = attribList[i+1];
+         if (version_major < 1)
+            return NULL;
+         break;
+      case OSMESA_CONTEXT_MINOR_VERSION:
+         version_minor = attribList[i+1];
+         if (version_minor < 0)
+            return NULL;
+         break;
+      case 0:
+         /* end of list */
+         break;
+      default:
+         fprintf(stderr, "Bad attribute in OSMesaCreateContextAttribs()\n");
+         return NULL;
+      }
+   }
+
+   osmesa = (OSMesaContext) CALLOC_STRUCT(osmesa_context);
+   if (!osmesa)
+      return NULL;
+
+   /* Choose depth/stencil/accum buffer formats */
+   if (accumBits > 0) {
+      osmesa->accum_format = PIPE_FORMAT_R16G16B16A16_SNORM;
+   }
+   if (depthBits > 0 && stencilBits > 0) {
+      osmesa->depth_stencil_format = PIPE_FORMAT_Z24_UNORM_S8_UINT;
+   }
+   else if (stencilBits > 0) {
+      osmesa->depth_stencil_format = PIPE_FORMAT_S8_UINT;
+   }
+   else if (depthBits >= 24) {
+      osmesa->depth_stencil_format = PIPE_FORMAT_Z24X8_UNORM;
+   }
+   else if (depthBits >= 16) {
+      osmesa->depth_stencil_format = PIPE_FORMAT_Z16_UNORM;
+   }
+
+   /*
+    * Create the rendering context
+    */
+   memset(&attribs, 0, sizeof(attribs));
+   attribs.profile = (profile == OSMESA_CORE_PROFILE)
+      ? ST_PROFILE_OPENGL_CORE : ST_PROFILE_DEFAULT;
+   attribs.major = version_major;
+   attribs.minor = version_minor;
+   attribs.flags = 0;  /* ST_CONTEXT_FLAG_x */
+   attribs.options.force_glsl_extensions_warn = FALSE;
+   attribs.options.disable_blend_func_extended = FALSE;
+   attribs.options.disable_glsl_line_continuations = FALSE;
+   attribs.options.force_glsl_version = 0;
+
+   osmesa_init_st_visual(&attribs.visual,
+                         PIPE_FORMAT_NONE,
+                         osmesa->depth_stencil_format,
+                         osmesa->accum_format);
+
+   osmesa->stctx = stapi->create_context(stapi, get_st_manager(),
+                                         &attribs, &st_error, st_shared);
+   if (!osmesa->stctx) {
+      char* st_error_str;
+      switch (st_error) {
+         case ST_CONTEXT_ERROR_NO_MEMORY:
+            st_error_str="ST_CONTEXT_ERROR_NO_MEMORY";
+            break;
+         case ST_CONTEXT_ERROR_BAD_API:
+            st_error_str="ST_CONTEXT_ERROR_BAD_API";
+            break;
+         case ST_CONTEXT_ERROR_BAD_VERSION:
+            st_error_str="ST_CONTEXT_ERROR_BAD_VERSION";
+            break;
+         case ST_CONTEXT_ERROR_BAD_FLAG:
+            st_error_str="ST_CONTEXT_ERROR_BAD_FLAG";
+            break;
+         case ST_CONTEXT_ERROR_UNKNOWN_ATTRIBUTE:
+            st_error_str="ST_CONTEXT_ERROR_UNKNOWN_ATTRIBUTE";
+            break;
+         case ST_CONTEXT_ERROR_UNKNOWN_FLAG:
+            st_error_str="ST_CONTEXT_ERROR_UNKNOWN_FLAG";
+            break;
+         default:
+            st_error_str="UNKNOWN";
+            break;
+      }
+      debug_printf("OSMESA: error: unable to create st context, st_error=%s",st_error_str);
+      FREE(osmesa);
+      return NULL;
+   }
+
+   osmesa->stctx->st_manager_private = osmesa;
+
+   osmesa->format = format;
+   osmesa->user_row_length = 0;
+   osmesa->y_up = GL_TRUE;
+
+   return osmesa;
+}
+
+
+
+/**
+ * Destroy an Off-Screen Mesa rendering context.
+ *
+ * \param osmesa  the context to destroy
+ */
+GLAPI void GLAPIENTRY
+OSMesaDestroyContext(OSMesaContext osmesa)
+{
+   if (osmesa) {
+      pp_free(osmesa->pp);
+      osmesa->stctx->destroy(osmesa->stctx);
+      free(osmesa->zs);
+      FREE(osmesa);
+   }
+}
+
+
+/**
+ * Bind an OSMesaContext to an image buffer.  The image buffer is just a
+ * block of memory which the client provides.  Its size must be at least
+ * as large as width*height*pixelSize.  Its address should be a multiple
+ * of 4 if using RGBA mode.
+ *
+ * By default, image data is stored in the order of glDrawPixels: row-major
+ * order with the lower-left image pixel stored in the first array position
+ * (ie. bottom-to-top).
+ *
+ * If the context's viewport hasn't been initialized yet, it will now be
+ * initialized to (0,0,width,height).
+ *
+ * Input:  osmesa - the rendering context
+ *         buffer - the image buffer memory
+ *         type - data type for pixel components
+ *                GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT
+ *                or GL_FLOAT.
+ *         width, height - size of image buffer in pixels, at least 1
+ * Return:  GL_TRUE if success, GL_FALSE if error because of invalid osmesa,
+ *          invalid type, invalid size, etc.
+ */
+GLAPI GLboolean GLAPIENTRY
+OSMesaMakeCurrent(OSMesaContext osmesa, void *buffer, GLenum type,
+                  GLsizei width, GLsizei height)
+{
+   struct st_api *stapi = get_st_api();
+   enum pipe_format color_format;
+
+   if (!osmesa && !buffer) {
+      stapi->make_current(stapi, NULL, NULL, NULL);
+      return GL_TRUE;
+   }
+
+   if (!osmesa || !buffer || width < 1 || height < 1) {
+      return GL_FALSE;
+   }
+
+   color_format = osmesa_choose_format(osmesa->format, type);
+   if (color_format == PIPE_FORMAT_NONE) {
+      fprintf(stderr, "OSMesaMakeCurrent(unsupported format/type)\n");
+      return GL_FALSE;
+   }
+
+   /* See if we already have a buffer that uses these pixel formats */
+   if (osmesa->current_buffer &&
+       (osmesa->current_buffer->visual.color_format != color_format ||
+        osmesa->current_buffer->visual.depth_stencil_format != osmesa->depth_stencil_format ||
+        osmesa->current_buffer->visual.accum_format != osmesa->accum_format)) {
+      osmesa_destroy_buffer(osmesa->current_buffer);
+   }
+
+   if (!osmesa->current_buffer) {
+      osmesa->current_buffer = osmesa_create_buffer(color_format,
+                                      osmesa->depth_stencil_format,
+                                      osmesa->accum_format);
+   }
+
+   struct osmesa_buffer *osbuffer = osmesa->current_buffer;
+
+   osbuffer->width = width;
+   osbuffer->height = height;
+   osbuffer->map = buffer;
+
+   osmesa->type = type;
+
+   stapi->make_current(stapi, osmesa->stctx, osbuffer->stfb, osbuffer->stfb);
+
+   /* XXX: We should probably load the current color value into the buffer here
+    * to match classic swrast behavior (context's fb starts with the contents of
+    * your pixel buffer).
+    */
+
+   if (!osmesa->ever_used) {
+      /* one-time init, just postprocessing for now */
+      boolean any_pp_enabled = FALSE;
+      unsigned i;
+
+      for (i = 0; i < ARRAY_SIZE(osmesa->pp_enabled); i++) {
+         if (osmesa->pp_enabled[i]) {
+            any_pp_enabled = TRUE;
+            break;
+         }
+      }
+
+      if (any_pp_enabled) {
+         osmesa->pp = pp_init(osmesa->stctx->pipe,
+                              osmesa->pp_enabled,
+                              osmesa->stctx->cso_context,
+                              osmesa->stctx);
+
+         pp_init_fbos(osmesa->pp, width, height);
+      }
+
+      osmesa->ever_used = TRUE;
+   }
+
+   return GL_TRUE;
+}
+
+
+
+GLAPI OSMesaContext GLAPIENTRY
+OSMesaGetCurrentContext(void)
+{
+   struct st_api *stapi = get_st_api();
+   struct st_context_iface *st = stapi->get_current(stapi);
+   return st ? (OSMesaContext) st->st_manager_private : NULL;
+}
+
+
+
+GLAPI void GLAPIENTRY
+OSMesaPixelStore(GLint pname, GLint value)
+{
+   OSMesaContext osmesa = OSMesaGetCurrentContext();
+
+   switch (pname) {
+   case OSMESA_ROW_LENGTH:
+      osmesa->user_row_length = value;
+      break;
+   case OSMESA_Y_UP:
+      osmesa->y_up = value ? GL_TRUE : GL_FALSE;
+      break;
+   default:
+      fprintf(stderr, "Invalid pname in OSMesaPixelStore()\n");
+      return;
+   }
+}
+
+
+GLAPI void GLAPIENTRY
+OSMesaGetIntegerv(GLint pname, GLint *value)
+{
+   OSMesaContext osmesa = OSMesaGetCurrentContext();
+   struct osmesa_buffer *osbuffer = osmesa ? osmesa->current_buffer : NULL;
+
+   switch (pname) {
+   case OSMESA_WIDTH:
+      *value = osbuffer ? osbuffer->width : 0;
+      return;
+   case OSMESA_HEIGHT:
+      *value = osbuffer ? osbuffer->height : 0;
+      return;
+   case OSMESA_FORMAT:
+      *value = osmesa->format;
+      return;
+   case OSMESA_TYPE:
+      /* current color buffer's data type */
+      *value = osmesa->type;
+      return;
+   case OSMESA_ROW_LENGTH:
+      *value = osmesa->user_row_length;
+      return;
+   case OSMESA_Y_UP:
+      *value = osmesa->y_up;
+      return;
+   case OSMESA_MAX_WIDTH:
+      FALLTHROUGH;
+   case OSMESA_MAX_HEIGHT:
+      {
+         struct pipe_screen *screen = get_st_manager()->screen;
+         *value = screen->get_param(screen, PIPE_CAP_MAX_TEXTURE_2D_SIZE);
+      }
+      return;
+   default:
+      fprintf(stderr, "Invalid pname in OSMesaGetIntegerv()\n");
+      return;
+   }
+}
+
+
+/**
+ * Return information about the depth buffer associated with an OSMesa context.
+ * Input:  c - the OSMesa context
+ * Output:  width, height - size of buffer in pixels
+ *          bytesPerValue - bytes per depth value (2 or 4)
+ *          buffer - pointer to depth buffer values
+ * Return:  GL_TRUE or GL_FALSE to indicate success or failure.
+ */
+GLAPI GLboolean GLAPIENTRY
+OSMesaGetDepthBuffer(OSMesaContext c, GLint *width, GLint *height,
+                     GLint *bytesPerValue, void **buffer)
+{
+   struct osmesa_buffer *osbuffer = c->current_buffer;
+   struct pipe_resource *res = osbuffer->textures[ST_ATTACHMENT_DEPTH_STENCIL];
+
+   if (!res) {
+      *width = 0;
+      *height = 0;
+      *bytesPerValue = 0;
+      *buffer = NULL;
+      return GL_FALSE;
+   }
+
+   *width = res->width0;
+   *height = res->height0;
+   *bytesPerValue = util_format_get_blocksize(res->format);
+
+   if (!c->zs) {
+      c->zs_stride = *width * *bytesPerValue;
+      c->zs = calloc(c->zs_stride, *height);
+      if (!c->zs)
+         return GL_FALSE;
+
+      osmesa_read_buffer(c, res, c->zs, c->zs_stride, true);
+   }
+
+   *buffer = c->zs;
+
+   return GL_TRUE;
+}
+
+
+/**
+ * Return the color buffer associated with an OSMesa context.
+ * Input:  c - the OSMesa context
+ * Output:  width, height - size of buffer in pixels
+ *          format - the pixel format (OSMESA_FORMAT)
+ *          buffer - pointer to color buffer values
+ * Return:  GL_TRUE or GL_FALSE to indicate success or failure.
+ */
+GLAPI GLboolean GLAPIENTRY
+OSMesaGetColorBuffer(OSMesaContext osmesa, GLint *width,
+                      GLint *height, GLint *format, void **buffer)
+{
+   struct osmesa_buffer *osbuffer = osmesa->current_buffer;
+
+   if (osbuffer) {
+      *width = osbuffer->width;
+      *height = osbuffer->height;
+      *format = osmesa->format;
+      *buffer = osbuffer->map;
+      return GL_TRUE;
+   }
+   else {
+      *width = 0;
+      *height = 0;
+      *format = 0;
+      *buffer = 0;
+      return GL_FALSE;
+   }
+}
+
+
+struct name_function
+{
+   const char *Name;
+   OSMESAproc Function;
+};
+
+static struct name_function functions[] = {
+   { "OSMesaCreateContext", (OSMESAproc) OSMesaCreateContext },
+   { "OSMesaCreateContextExt", (OSMESAproc) OSMesaCreateContextExt },
+   { "OSMesaCreateContextAttribs", (OSMESAproc) OSMesaCreateContextAttribs },
+   { "OSMesaDestroyContext", (OSMESAproc) OSMesaDestroyContext },
+   { "OSMesaMakeCurrent", (OSMESAproc) OSMesaMakeCurrent },
+   { "OSMesaGetCurrentContext", (OSMESAproc) OSMesaGetCurrentContext },
+   { "OSMesaPixelStore", (OSMESAproc) OSMesaPixelStore },
+   { "OSMesaGetIntegerv", (OSMESAproc) OSMesaGetIntegerv },
+   { "OSMesaGetDepthBuffer", (OSMESAproc) OSMesaGetDepthBuffer },
+   { "OSMesaGetColorBuffer", (OSMESAproc) OSMesaGetColorBuffer },
+   { "OSMesaGetProcAddress", (OSMESAproc) OSMesaGetProcAddress },
+   { "OSMesaColorClamp", (OSMESAproc) OSMesaColorClamp },
+   { "OSMesaPostprocess", (OSMESAproc) OSMesaPostprocess },
+   { NULL, NULL }
+};
+
+
+GLAPI OSMESAproc GLAPIENTRY
+OSMesaGetProcAddress(const char *funcName)
+{
+   int i;
+   for (i = 0; functions[i].Name; i++) {
+      if (strcmp(functions[i].Name, funcName) == 0)
+         return functions[i].Function;
+   }
+   return _glapi_get_proc_address(funcName);
+}
+
+
+GLAPI void GLAPIENTRY
+OSMesaColorClamp(GLboolean enable)
+{
+   extern void GLAPIENTRY _mesa_ClampColor(GLenum target, GLenum clamp);
+
+   _mesa_ClampColor(GL_CLAMP_FRAGMENT_COLOR_ARB,
+                    enable ? GL_TRUE : GL_FIXED_ONLY_ARB);
+}
+
+
+GLAPI void GLAPIENTRY
+OSMesaPostprocess(OSMesaContext osmesa, const char *filter,
+                  unsigned enable_value)
+{
+   if (!osmesa->ever_used) {
+      /* We can only enable/disable postprocess filters before a context
+       * is made current for the first time.
+       */
+      unsigned i;
+
+      for (i = 0; i < PP_FILTERS; i++) {
+         if (strcmp(pp_filters[i].name, filter) == 0) {
+            osmesa->pp_enabled[i] = enable_value;
+            return;
+         }
+      }
+      debug_warning("OSMesaPostprocess(unknown filter)\n");
+   }
+   else {
+      debug_warning("Calling OSMesaPostprocess() after OSMesaMakeCurrent()\n");
+   }
+}
diff --git a/src/gallium/include/frontend/api.h b/src/gallium/include/frontend/api.h
index d0e13d4..bf4667e 100644
--- a/src/gallium/include/frontend/api.h
+++ b/src/gallium/include/frontend/api.h
@@ -387,6 +387,11 @@ struct st_context_iface
     */
    struct pipe_context *pipe;
 
+   /**
+    * Should we flush front buffer?
+    */
+   bool should_flush_frontbuffer;
+
    /**
     * Destroy the context.
     */
diff --git a/src/gallium/targets/dri/target.c b/src/gallium/targets/dri/target.c
index 2788fbd..26423d0 100644
--- a/src/gallium/targets/dri/target.c
+++ b/src/gallium/targets/dri/target.c
@@ -3,12 +3,16 @@
 
 #include "dri_screen.h"
 
+
+   //globalDriverAPI = &galliumdrm_driver_api;                              \
+   //return galliumdrm_driver_extensions;                                   \
+
 #define DEFINE_LOADER_DRM_ENTRYPOINT(drivername)                          \
 const __DRIextension **__driDriverGetExtensions_##drivername(void);       \
 PUBLIC const __DRIextension **__driDriverGetExtensions_##drivername(void) \
 {                                                                         \
-   globalDriverAPI = &galliumdrm_driver_api;                              \
-   return galliumdrm_driver_extensions;                                   \
+   printf("STUB: __driDriverGetExtensions_swrast\n");                       \
+   return NULL;                                                             \
 }
 
 #if defined(GALLIUM_SOFTPIPE)
@@ -17,8 +21,10 @@ const __DRIextension **__driDriverGetExtensions_swrast(void);
 
 PUBLIC const __DRIextension **__driDriverGetExtensions_swrast(void)
 {
-   globalDriverAPI = &galliumsw_driver_api;
-   return galliumsw_driver_extensions;
+   //globalDriverAPI = &galliumsw_driver_api;
+   //return galliumsw_driver_extensions;
+   printf("STUB: __driDriverGetExtensions_swrast\n");
+   return NULL;
 }
 
 #if defined(HAVE_LIBDRM)
@@ -123,7 +129,8 @@ DEFINE_LOADER_DRM_ENTRYPOINT(sun4i_drm)
 DEFINE_LOADER_DRM_ENTRYPOINT(lima)
 #endif
 
-#if defined(GALLIUM_ZINK) && !defined(__APPLE__)
+#if defined(GALLIUM_ZINK)
+// && !defined(__APPLE__)
 DEFINE_LOADER_DRM_ENTRYPOINT(zink);
 #endif
 
diff --git a/src/gallium/targets/osmesa/meson.build b/src/gallium/targets/osmesa/meson.build
index 3a421b5..5cd4f7a 100644
--- a/src/gallium/targets/osmesa/meson.build
+++ b/src/gallium/targets/osmesa/meson.build
@@ -55,7 +55,7 @@ libosmesa = shared_library(
   ],
   dependencies : [
     dep_ws2_32, dep_selinux, dep_thread, dep_clock, dep_unwind,
-    driver_swrast, driver_swr,
+    driver_swrast, driver_swr, driver_virgl, driver_zink, idep_xmlconfig,
   ],
   name_prefix : host_machine.system() == 'windows' ? '' : 'lib',  # otherwise mingw will create libosmesa.dll
   soversion : host_machine.system() == 'windows' ? '' : '8',
diff --git a/src/gallium/targets/osmesa/osmesa.sym b/src/gallium/targets/osmesa/osmesa.sym
index 59beab3..e92aa68 100644
--- a/src/gallium/targets/osmesa/osmesa.sym
+++ b/src/gallium/targets/osmesa/osmesa.sym
@@ -15,6 +15,7 @@
 		OSMesaPostprocess;
 		gl*;
 		mgl*;
+		st*;
 	local:
 		*;
 };
diff --git a/src/gallium/targets/osmesa/target.c b/src/gallium/targets/osmesa/target.c
index 25985dd..925224f 100644
--- a/src/gallium/targets/osmesa/target.c
+++ b/src/gallium/targets/osmesa/target.c
@@ -20,7 +20,8 @@
  * OTHER DEALINGS IN THE SOFTWARE.
  */
 
-
+#include <stdio.h>
+ 
 #include "target-helpers/inline_sw_helper.h"
 #include "target-helpers/inline_debug_helper.h"
 
@@ -41,16 +42,20 @@ osmesa_create_screen(void)
     * driver resources.
     */
    winsys = null_sw_create();
-   if (!winsys)
+   if (!winsys) {
+      printf("OSMESA_TARGET: winsys is null\n");
       return NULL;
+   }
 
    /* Create llvmpipe or softpipe screen */
    screen = sw_screen_create(winsys);
    if (!screen) {
+      printf("OSMESA_TARGET: generated screen is null\n");
       winsys->destroy(winsys);
       return NULL;
    }
 
+   printf("OSMESA_TARGET: screen=%p\n",screen);
    /* Inject optional trace, debug, etc. wrappers */
    return debug_screen_wrap(screen);
 }
diff --git a/src/gallium/winsys/sw/dri/dri_sw_winsys.c b/src/gallium/winsys/sw/dri/dri_sw_winsys.c
index 74181a7..f763215 100644
--- a/src/gallium/winsys/sw/dri/dri_sw_winsys.c
+++ b/src/gallium/winsys/sw/dri/dri_sw_winsys.c
@@ -26,6 +26,10 @@
  *
  **************************************************************************/
 
+#if ANDROID_API_LEVEL < 26
+#undef HAVE_SYS_SHM_H
+#endif
+
 #ifdef HAVE_SYS_SHM_H
 #include <sys/ipc.h>
 #include <sys/shm.h>
diff --git a/src/gallium/winsys/virgl/drm/empty.c b/src/gallium/winsys/virgl/drm/empty.c
new file mode 100644
index 0000000..8b13789
--- /dev/null
+++ b/src/gallium/winsys/virgl/drm/empty.c
@@ -0,0 +1 @@
+
diff --git a/src/gallium/winsys/virgl/drm/meson.build b/src/gallium/winsys/virgl/drm/meson.build
index d4decb0..332e970 100644
--- a/src/gallium/winsys/virgl/drm/meson.build
+++ b/src/gallium/winsys/virgl/drm/meson.build
@@ -18,9 +18,10 @@
 # OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 # SOFTWARE.
 
+#   'virgl_drm_winsys.c',
 libvirgldrm = static_library(
   'virgldrm',
-  'virgl_drm_winsys.c',
+  'empty.c',
   include_directories : [inc_include, inc_src, inc_mapi, inc_mesa, inc_gallium, inc_gallium_aux, inc_gallium_drivers, inc_virtio],
   dependencies : [dep_libdrm, dep_libvirglcommon, idep_mesautil],
   gnu_symbol_visibility : 'hidden',
diff --git a/src/gallium/winsys/virgl/vtest/virgl_vtest_socket.c b/src/gallium/winsys/virgl/vtest/virgl_vtest_socket.c
index f24116e..e23ac0f 100644
--- a/src/gallium/winsys/virgl/vtest/virgl_vtest_socket.c
+++ b/src/gallium/winsys/virgl/vtest/virgl_vtest_socket.c
@@ -204,7 +204,9 @@ int virgl_vtest_connect(struct virgl_vtest_winsys *vws)
 
    memset(&un, 0, sizeof(un));
    un.sun_family = AF_UNIX;
-   snprintf(un.sun_path, sizeof(un.sun_path), "%s", VTEST_DEFAULT_SOCKET_NAME);
+   const char *override_socket_name = getenv("VTEST_SOCKET_NAME");
+   snprintf(un.sun_path, sizeof(un.sun_path), "%s", override_socket_name ?
+      override_socket_name : VTEST_DEFAULT_SOCKET_NAME);
 
    do {
       ret = 0;
diff --git a/src/glx/apple/meson.build b/src/glx/apple/meson.build
index f88c22d..a315feb 100644
--- a/src/glx/apple/meson.build
+++ b/src/glx/apple/meson.build
@@ -48,7 +48,7 @@ files_libappleglx = files(
 
 dep_xplugin = null_dep
 if with_dri_platform == 'apple'
-  dep_xplugin = meson.get_compiler('c').find_library('Xplugin')
+  # dep_xplugin = meson.get_compiler('c').find_library('Xplugin')
 endif
 
 libappleglx = static_library(
diff --git a/src/glx/empty.c b/src/glx/empty.c
new file mode 100644
index 0000000..d3f5a12
--- /dev/null
+++ b/src/glx/empty.c
@@ -0,0 +1 @@
+
diff --git a/src/glx/meson.build b/src/glx/meson.build
index 8f642d5..000acde 100644
--- a/src/glx/meson.build
+++ b/src/glx/meson.build
@@ -73,6 +73,10 @@ files_libglx = files(
   'xfont.c',
 )
 
+if with_platform_android or host_machine.system() == 'darwin'
+dep_xdamage = null_dep
+endif
+
 extra_libs_libglx = []
 extra_deps_libgl = []
 extra_ld_args_libgl = []
@@ -124,7 +128,7 @@ endif
 
 libglx = static_library(
   'glx',
-  [files_libglx, glx_generated],
+  not with_platform_android and host_machine.system() != 'darwin' ? [files_libglx, glx_generated] : files('empty.c'),
   include_directories : [inc_include, inc_src, inc_mapi, inc_mesa, inc_gallium, inc_gallium_aux, inc_glapi, inc_loader],
   c_args : [
     '-DGL_LIB_NAME="lib@0@.so.@1@"'.format(gl_lib_name, gl_lib_version.split('.')[0]),
@@ -143,12 +147,14 @@ libglx = static_library(
 libgl = shared_library(
   gl_lib_name,
   [],
-  link_with : [libglapi_static, libglapi],
-  link_whole : libglx,
+  link_with : [libglapi],
+  link_whole : [
+    libglx, libglapi_static, libdricommon, libmegadriver_stub,
+  ],
   link_args : [ld_args_bsymbolic, ld_args_gc_sections, extra_ld_args_libgl],
   dependencies : [
     dep_libdrm, dep_dl, dep_m, dep_thread, dep_x11, dep_xcb_glx, dep_xcb,
-    dep_x11_xcb, dep_xcb_dri2, dep_xext, dep_xfixes, dep_xxf86vm,
+    dep_x11_xcb, dep_xcb_dri2, dep_xext, dep_xfixes, dep_xdamage, dep_xxf86vm,
     dep_xcb_shm, extra_deps_libgl,
   ],
   version : gl_lib_version,
diff --git a/src/mesa/main/texcompress_s3tc_tmp.h b/src/mesa/main/texcompress_s3tc_tmp.h
index 5dd2522..90085ad 100644
--- a/src/mesa/main/texcompress_s3tc_tmp.h
+++ b/src/mesa/main/texcompress_s3tc_tmp.h
@@ -25,7 +25,7 @@
 #ifndef TEXCOMPRESS_S3TC_TMP_H
 #define TEXCOMPRESS_S3TC_TMP_H
 
-#ifdef __APPLE__
+#ifdef __APPLE___COMMENTED_OUT
 #include <OpenGL/gl.h>
 #else
 #include <GL/gl.h>
diff --git a/src/mesa/state_tracker/st_cb_flush.c b/src/mesa/state_tracker/st_cb_flush.c
index 97e0c73..0b30921 100644
--- a/src/mesa/state_tracker/st_cb_flush.c
+++ b/src/mesa/state_tracker/st_cb_flush.c
@@ -98,6 +98,7 @@ st_glFlush(struct gl_context *ctx, unsigned gallium_flush_flags)
     */
    st_flush(st, NULL, gallium_flush_flags);
 
+   if (st->iface.should_flush_frontbuffer)
    st_manager_flush_frontbuffer(st);
 }
 
@@ -112,6 +113,7 @@ st_glFinish(struct gl_context *ctx)
 
    st_finish(st);
 
+   if (st->iface.should_flush_frontbuffer)
    st_manager_flush_frontbuffer(st);
 }
 
diff --git a/src/mesa/state_tracker/st_manager.c b/src/mesa/state_tracker/st_manager.c
index 48b87b7..9f89d7c 100644
--- a/src/mesa/state_tracker/st_manager.c
+++ b/src/mesa/state_tracker/st_manager.c
@@ -1004,6 +1004,7 @@ st_api_create_context(struct st_api *stapi, struct st_manager *smapi,
    st->iface.cso_context = st->cso_context;
    st->iface.pipe = st->pipe;
    st->iface.state_manager = smapi;
+   st->iface.should_flush_frontbuffer = getenv("OSMESA_NO_FLUSH_FRONTBUFFER") == NULL;
 
    if (st->ctx->IntelBlackholeRender &&
        st->screen->get_param(st->screen, PIPE_CAP_FRONTEND_NOOP))
diff --git a/src/util/libsync.h b/src/util/libsync.h
index 1c9303c..3b763b7 100644
--- a/src/util/libsync.h
+++ b/src/util/libsync.h
@@ -41,7 +41,8 @@
 extern "C" {
 #endif
 
-#ifdef ANDROID
+//#ifdef ANDROID
+#if ANDROID_API_LEVEL >= 26
 /* On Android, rely on the system's libsync instead of rolling our own
  * sync_wait() and sync_merge().  This gives us compatibility with pre-4.7
  * Android kernels.
diff --git a/sync.pc b/sync.pc
new file mode 100644
index 0000000..521c3a8
--- /dev/null
+++ b/sync.pc
@@ -0,0 +1,4 @@
+Name: sync
+Description: Android libsync library
+Version: 1.0
+Libs:
diff --git a/vulkan_android.pc b/vulkan_android.pc
new file mode 100644
index 0000000..8bd0312
--- /dev/null
+++ b/vulkan_android.pc
@@ -0,0 +1,4 @@
+Name: vulkan
+Description: Android Vulkan library
+Version: 1.2
+Libs:
diff --git a/vulkan_ios.pc b/vulkan_ios.pc
new file mode 100644
index 0000000..a90a06f
--- /dev/null
+++ b/vulkan_ios.pc
@@ -0,0 +1,4 @@
+Name: vulkan
+Description: MoltenVK library
+Version: 1.2
+Libs: -L/Users/runner/work/mesa/mesa/ext -lMoltenVK
