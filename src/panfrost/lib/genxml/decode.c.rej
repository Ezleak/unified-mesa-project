diff a/src/panfrost/lib/genxml/decode.c b/src/panfrost/lib/genxml/decode.c	(rejected hunks)
@@ -54,6 +54,12 @@
         pan_section_print(pandecode_dump_stream, A, S, temp, (pandecode_indent + 1) * 2); \
 }
 
+#define DUMP_SECTION_CS_V10(A, S, cl, buf, buf_unk, ...) { \
+        pan_section_unpack_cs_v10(cl, buf, buf_unk, A, S, temp); \
+        pandecode_log(__VA_ARGS__); \
+        pan_section_print(pandecode_dump_stream, A, S, temp, (pandecode_indent + 1) * 2); \
+}
+
 #define MAP_ADDR(T, addr, cl) \
         const uint8_t *cl = pandecode_fetch_gpu_mem(addr, pan_size(T));
 
@@ -158,7 +164,7 @@ pandecode_midgard_tiler_descriptor(
         if (nonzero_weights)
                 DUMP_UNPACKED(TILER_WEIGHTS, w, "Tiler Weights:\n");
 }
-#endif
+#endif /* PAN_ARCH <= 5 */
 
 #if PAN_ARCH >= 5
 static void
@@ -184,7 +190,7 @@ pandecode_render_target(uint64_t gpu_va, unsigned gpu_id,
         pandecode_indent--;
         pandecode_log("\n");
 }
-#endif
+#endif /* PAN_ARCH >= 5 */
 
 #if PAN_ARCH >= 6
 static void
@@ -201,7 +207,7 @@ pandecode_sample_locations(const void *fb)
                                 samples[2 * i + 1] - 128);
         }
 }
-#endif
+#endif /* PAN_ARCH >= 6 */
 
 static void
 pandecode_dcd(const struct MALI_DRAW *p, enum mali_job_type job_type,
@@ -228,29 +234,29 @@ pandecode_fbd(uint64_t gpu_va, bool is_fragment, unsigned gpu_id)
 #if PAN_ARCH >= 6
         pandecode_sample_locations(fb);
 
-        unsigned dcd_size = pan_size(DRAW);
+        unsigned dcd_size = pan_size(DRAW_NO_CS);
 
         if (params.pre_frame_0 != MALI_PRE_POST_FRAME_SHADER_MODE_NEVER) {
                 const void *PANDECODE_PTR_VAR(dcd, params.frame_shader_dcds + (0 * dcd_size));
-                pan_unpack(dcd, DRAW, draw);
+                pan_unpack(dcd, DRAW_NO_CS, draw);
                 pandecode_log("Pre frame 0:\n");
                 pandecode_dcd(&draw, MALI_JOB_TYPE_FRAGMENT, gpu_id);
         }
 
         if (params.pre_frame_1 != MALI_PRE_POST_FRAME_SHADER_MODE_NEVER) {
                 const void *PANDECODE_PTR_VAR(dcd, params.frame_shader_dcds + (1 * dcd_size));
-                pan_unpack(dcd, DRAW, draw);
+                pan_unpack(dcd, DRAW_NO_CS, draw);
                 pandecode_log("Pre frame 1:\n");
                 pandecode_dcd(&draw, MALI_JOB_TYPE_FRAGMENT, gpu_id);
         }
 
         if (params.post_frame != MALI_PRE_POST_FRAME_SHADER_MODE_NEVER) {
                 const void *PANDECODE_PTR_VAR(dcd, params.frame_shader_dcds + (2 * dcd_size));
-                pan_unpack(dcd, DRAW, draw);
+                pan_unpack(dcd, DRAW_NO_CS, draw);
                 pandecode_log("Post frame:\n");
                 pandecode_dcd(&draw, MALI_JOB_TYPE_FRAGMENT, gpu_id);
         }
-#else
+#else /* PAN_ARCH < 6 */
         DUMP_SECTION(FRAMEBUFFER, LOCAL_STORAGE, fb, "Local Storage:\n");
 
         const void *t = pan_section_ptr(fb, FRAMEBUFFER, TILER);
@@ -284,7 +290,7 @@ pandecode_fbd(uint64_t gpu_va, bool is_fragment, unsigned gpu_id)
                 .rt_count = params.render_target_count,
                 .has_extra = params.has_zs_crc_extension
         };
-#else
+#else /* PAN_ARCH < 5 */
         /* Dummy unpack of the padding section to make sure all words are 0.
          * No need to call print here since the section is supposed to be empty.
          */
@@ -341,7 +347,7 @@ pandecode_attributes(mali_ptr addr, int count,
         }
         pandecode_log("\n");
 }
-#endif
+#endif /* PAN_ARCH <= 7 */
 
 #if PAN_ARCH >= 5
 static mali_ptr
@@ -358,7 +364,7 @@ pandecode_blend(void *descs, int rt_no, mali_ptr frag_shader)
         return b.blend_shader ? (b.shader_pc & ~0xf) : 0;
 #endif
 }
-#endif
+#endif /* PAN_ARCH >= 6 || PAN_ARCH == 5 */
 
 #if PAN_ARCH <= 7
 static unsigned
@@ -412,8 +418,9 @@ pandecode_invocation(const void *i)
 
         DUMP_UNPACKED(INVOCATION, invocation, "Invocation:\n")
 }
-#endif
+#endif /* PAN_ARCH <= 7 */
 
+#if PAN_ARCH < 10
 static void
 pandecode_primitive(const void *p)
 {
@@ -439,7 +446,7 @@ pandecode_primitive(const void *p)
                         pandecode_validate_buffer(primitive.indices, primitive.index_count * size);
         } else if (primitive.index_type)
                 pandecode_log("// XXX: unexpected index size\n");
-#endif
+#endif /* PAN_ARCH <= 7 */
 }
 
 static void
@@ -451,6 +458,7 @@ pandecode_primitive_size(const void *s, bool constant)
 
         DUMP_UNPACKED(PRIMITIVE_SIZE, ps, "Primitive Size:\n")
 }
+#endif /* PAN_ARCH < 10 */
 
 #if PAN_ARCH <= 7
 static void
@@ -482,7 +490,7 @@ pandecode_uniforms(mali_ptr uniforms, unsigned uniform_count)
         free(ptr);
         pandecode_log("\n");
 }
-#endif
+#endif /* PAN_ARCH <= 7 */
 
 static void
 pandecode_shader_disassemble(mali_ptr shader_ptr, int type, unsigned gpu_id)
@@ -566,7 +574,7 @@ pandecode_texture_payload(mali_ptr payload,
         pandecode_indent--;
         pandecode_log("},\n");
 }
-#endif
+#endif /* PAN_ARCH <= 7 */
 
 #if PAN_ARCH <= 5
 static void
@@ -585,7 +593,7 @@ pandecode_texture(mali_ptr u, unsigned tex)
                         temp.levels, nr_samples, temp.array_size);
         pandecode_indent--;
 }
-#else
+#else /* PAN_ARCH > 5 */
 static void
 pandecode_texture(const void *cl, unsigned tex)
 {
@@ -603,7 +611,7 @@ pandecode_texture(const void *cl, unsigned tex)
 
         for (unsigned i = 0; i < plane_count; ++i)
                 DUMP_ADDR(PLANE, temp.surfaces + i * pan_size(PLANE), "Plane %u:\n", i);
-#else
+#else /* PAN_ARCH < 9 */
         unsigned nr_samples = temp.dimension == MALI_TEXTURE_DIMENSION_3D ?
                               1 : temp.sample_count;
 
@@ -630,7 +638,7 @@ pandecode_textures(mali_ptr textures, unsigned texture_count)
 
         for (unsigned tex = 0; tex < texture_count; ++tex)
                 pandecode_texture(cl + pan_size(TEXTURE) * tex, tex);
-#else
+#else /* PAN_ARCH < 6 */
         mali_ptr *PANDECODE_PTR_VAR(u, textures);
 
         for (int tex = 0; tex < texture_count; ++tex) {
@@ -741,7 +749,7 @@ pandecode_dcd(const struct MALI_DRAW *p, enum mali_job_type job_type,
                                                                            gpu_id);
                         }
                 }
-#endif
+#endif /* PAN_ARCH >= 5 */
         } else
                 pandecode_log("// XXX: missing shader descriptor\n");
 
@@ -807,7 +815,7 @@ pandecode_vertex_compute_geometry_job(const struct MALI_JOB_HEADER *h,
         pandecode_indent--;
         pandecode_log("\n");
 }
-#endif
+#endif /* PAN_ARCH <= 7 */
 
 #if PAN_ARCH >= 6
 static void
@@ -823,6 +831,10 @@ pandecode_tiler(mali_ptr gpu_va)
         DUMP_UNPACKED(TILER_CONTEXT, t, "Tiler:\n");
 }
 
+#endif /* PAN_ARCH >= 6 */
+
+#if PAN_ARCH < 10
+#if PAN_ARCH >= 6
 #if PAN_ARCH <= 7
 static void
 pandecode_indexed_vertex_job(const struct MALI_JOB_HEADER *h,
@@ -854,8 +866,8 @@ pandecode_indexed_vertex_job(const struct MALI_JOB_HEADER *h,
 
         pan_section_unpack(p, INDEXED_VERTEX_JOB, PADDING, padding);
 }
-#endif
-#endif
+#endif /* PAN_ARCH <= 7 */
+#endif /* PAN_ARCH >= 6 */
 
 static void
 pandecode_tiler_job(const struct MALI_JOB_HEADER *h,
@@ -890,7 +902,7 @@ pandecode_tiler_job(const struct MALI_JOB_HEADER *h,
         pan_section_unpack(p, TILER_JOB, PADDING, padding);
 #endif
 
-#else
+#else /* PAN_ARCH < 6 */
         pan_section_unpack(p, TILER_JOB, PRIMITIVE, primitive);
         pandecode_primitive_size(pan_section_ptr(p, TILER_JOB, PRIMITIVE_SIZE),
                                  primitive.point_size_array_format == MALI_POINT_SIZE_ARRAY_FORMAT_NONE);
@@ -898,12 +910,17 @@ pandecode_tiler_job(const struct MALI_JOB_HEADER *h,
         pandecode_indent--;
         pandecode_log("\n");
 }
+#endif /* PAN_ARCH < 10 */
 
 static void
-pandecode_fragment_job(mali_ptr job, unsigned gpu_id)
+pandecode_fragment_job(mali_ptr job, uint32_t *cs_buf, uint32_t *cs_buf_unk,
+                       unsigned gpu_id)
 {
+#if PAN_ARCH < 10
         struct mali_fragment_job_packed *PANDECODE_PTR_VAR(p, job);
-        pan_section_unpack(p, FRAGMENT_JOB, PAYLOAD, s);
+#endif
+
+        pan_section_unpack_cs_v10(p, cs_buf, cs_buf_unk, FRAGMENT_JOB, PAYLOAD, s);
 
         UNUSED struct pandecode_fbd info = pandecode_fbd(s.framebuffer, true, gpu_id);
 
@@ -920,7 +937,7 @@ pandecode_fragment_job(mali_ptr job, unsigned gpu_id)
                 expected_tag |= MALI_FBD_TAG_HAS_ZS_RT;
 
         expected_tag |= MALI_FBD_TAG_IS_MFBD | (MALI_POSITIVE(info.rt_count) << 2);
-#endif
+#endif /* PAN_ARCH >= 5 */
 
         DUMP_UNPACKED(FRAGMENT_JOB_PAYLOAD, s, "Fragment Job Payload:\n");
 
@@ -936,6 +953,8 @@ pandecode_fragment_job(mali_ptr job, unsigned gpu_id)
         pandecode_log("\n");
 }
 
+#if PAN_ARCH < 10
+// TODO: Use the same model as for malloc_vertex jobs?
 static void
 pandecode_write_value_job(mali_ptr job)
 {
@@ -953,6 +972,7 @@ pandecode_cache_flush_job(mali_ptr job)
         DUMP_SECTION(CACHE_FLUSH_JOB, PAYLOAD, p, "Cache Flush Payload:\n");
         pandecode_log("\n");
 }
+#endif /* PAN_ARCH < 10 */
 
 #if PAN_ARCH >= 9
 static void
@@ -1034,6 +1054,9 @@ pandecode_resource_tables(mali_ptr addr, const char *label)
 static void
 pandecode_depth_stencil(mali_ptr addr)
 {
+        if (!addr)
+                return;
+
         MAP_ADDR(DEPTH_STENCIL, addr, cl);
         pan_unpack(cl, DEPTH_STENCIL, desc);
         DUMP_UNPACKED(DEPTH_STENCIL, desc, "Depth/stencil");
@@ -1060,14 +1083,15 @@ static void
 pandecode_dcd(const struct MALI_DRAW *p, enum mali_job_type job_type,
               unsigned gpu_id)
 {
-        mali_ptr frag_shader = 0;
-
         pandecode_depth_stencil(p->depth_stencil);
 
         for (unsigned i = 0; i < p->blend_count; ++i) {
+                MAP_ADDR(SHADER_PROGRAM, p->shader.shader, cl);
+                pan_unpack(cl, SHADER_PROGRAM, desc);
+
                 struct mali_blend_packed *PANDECODE_PTR_VAR(blend_descs, p->blend);
 
-                mali_ptr blend_shader = pandecode_blend(blend_descs, i, frag_shader);
+                mali_ptr blend_shader = pandecode_blend(blend_descs, i, desc.binary);
                 if (blend_shader) {
                         fprintf(pandecode_dump_stream, "Blend shader %u", i);
                         pandecode_shader_disassemble(blend_shader, 0, gpu_id);
@@ -1079,21 +1103,26 @@ pandecode_dcd(const struct MALI_DRAW *p, enum mali_job_type job_type,
 }
 
 static void
-pandecode_malloc_vertex_job(mali_ptr job, unsigned gpu_id)
+pandecode_malloc_vertex_job(mali_ptr job, uint32_t *cs_buf, uint32_t *cs_buf_unk,
+                            unsigned gpu_id)
 {
+#if PAN_ARCH < 10
         struct mali_malloc_vertex_job_packed *PANDECODE_PTR_VAR(p, job);
+#endif
 
-        DUMP_SECTION(MALLOC_VERTEX_JOB, PRIMITIVE, p, "Primitive:\n");
-        DUMP_SECTION(MALLOC_VERTEX_JOB, INSTANCE_COUNT, p, "Instance count:\n");
+        DUMP_SECTION_CS_V10(MALLOC_VERTEX_JOB, PRIMITIVE, p, cs_buf, cs_buf_unk, "Primitive:\n");
+        DUMP_SECTION_CS_V10(MALLOC_VERTEX_JOB, INSTANCE_COUNT, p, cs_buf, cs_buf_unk, "Instance count:\n");
+#if PAN_ARCH < 10
         DUMP_SECTION(MALLOC_VERTEX_JOB, ALLOCATION, p, "Allocation:\n");
-        DUMP_SECTION(MALLOC_VERTEX_JOB, TILER, p, "Tiler:\n");
-        DUMP_SECTION(MALLOC_VERTEX_JOB, SCISSOR, p, "Scissor:\n");
-        DUMP_SECTION(MALLOC_VERTEX_JOB, PRIMITIVE_SIZE, p, "Primitive Size:\n");
-        DUMP_SECTION(MALLOC_VERTEX_JOB, INDICES, p, "Indices:\n");
+#endif
+        DUMP_SECTION_CS_V10(MALLOC_VERTEX_JOB, TILER, p, cs_buf, cs_buf_unk, "Tiler:\n");
+        DUMP_SECTION_CS_V10(MALLOC_VERTEX_JOB, SCISSOR, p, cs_buf, cs_buf_unk, "Scissor:\n");
+        DUMP_SECTION_CS_V10(MALLOC_VERTEX_JOB, PRIMITIVE_SIZE, p, cs_buf, cs_buf_unk, "Primitive Size:\n");
+        DUMP_SECTION_CS_V10(MALLOC_VERTEX_JOB, INDICES, p, cs_buf, cs_buf_unk, "Indices:\n");
 
-        pan_section_unpack(p, MALLOC_VERTEX_JOB, DRAW, dcd);
+        pan_section_unpack_cs_v10(p, cs_buf, cs_buf_unk, MALLOC_VERTEX_JOB, DRAW, dcd);
 
-        pan_section_unpack(p, MALLOC_VERTEX_JOB, TILER, tiler_ptr);
+        pan_section_unpack_cs_v10(p, cs_buf, cs_buf_unk, MALLOC_VERTEX_JOB, TILER, tiler_ptr);
         pandecode_log("Tiler Job Payload:\n");
         pandecode_indent++;
         if (tiler_ptr.address)
@@ -1104,17 +1133,20 @@ pandecode_malloc_vertex_job(mali_ptr job, unsigned gpu_id)
 
         pandecode_dcd(&dcd, 0, gpu_id);
 
-        pan_section_unpack(p, MALLOC_VERTEX_JOB, POSITION, position);
-        pan_section_unpack(p, MALLOC_VERTEX_JOB, VARYING, varying);
+        pan_section_unpack_cs_v10(p, cs_buf, cs_buf_unk, MALLOC_VERTEX_JOB, POSITION, position);
+        pan_section_unpack_cs_v10(p, cs_buf, cs_buf_unk, MALLOC_VERTEX_JOB, VARYING, varying);
         pandecode_shader_environment(&position, gpu_id);
         pandecode_shader_environment(&varying, gpu_id);
 }
 
 static void
-pandecode_compute_job(mali_ptr job, unsigned gpu_id)
+pandecode_compute_job(mali_ptr job, uint32_t *cs_buf, uint32_t *cs_buf_unk,
+                      unsigned gpu_id)
 {
+#if PAN_ARCH < 10
 	struct mali_compute_job_packed *PANDECODE_PTR_VAR(p, job);
-	pan_section_unpack(p, COMPUTE_JOB, PAYLOAD, payload);
+#endif
+	pan_section_unpack_cs_v10(p, cs_buf, cs_buf_unk, COMPUTE_JOB, PAYLOAD, payload);
 
 	pandecode_shader(payload.compute.shader, "Shader", gpu_id);
 	if (payload.compute.thread_storage)
@@ -1126,8 +1158,9 @@ pandecode_compute_job(mali_ptr job, unsigned gpu_id)
 
 	DUMP_UNPACKED(COMPUTE_PAYLOAD, payload, "Compute:\n");
 }
-#endif
+#endif /* PAN_ARCH >= 9 */
 
+#if PAN_ARCH < 10
 /* Entrypoint to start tracing. jc_gpu_va is the GPU address for the first job
  * in the chain; later jobs are found by walking the chain. GPU ID is the
  * more finegrained ID because some details are model-specific even within a
@@ -1183,18 +1216,18 @@ GENX(pandecode_jc)(mali_ptr jc_gpu_va, unsigned gpu_id)
                         pandecode_indexed_vertex_job(&h, jc_gpu_va, gpu_id);
                         break;
 #endif
-#else
+#else /* PAN_ARCH > 7 */
 		case MALI_JOB_TYPE_COMPUTE:
-			pandecode_compute_job(jc_gpu_va, gpu_id);
+                        pandecode_compute_job(jc_gpu_va, NULL, NULL, gpu_id);
 			break;
 
 		case MALI_JOB_TYPE_MALLOC_VERTEX:
-			pandecode_malloc_vertex_job(jc_gpu_va, gpu_id);
+			pandecode_malloc_vertex_job(jc_gpu_va, NULL, NULL, gpu_id);
 			break;
 #endif
 
                 case MALI_JOB_TYPE_FRAGMENT:
-                        pandecode_fragment_job(jc_gpu_va, gpu_id);
+                        pandecode_fragment_job(jc_gpu_va, NULL, NULL, gpu_id);
                         break;
 
                 default:
@@ -1232,3 +1265,544 @@ GENX(pandecode_abort_on_fault)(mali_ptr jc_gpu_va)
 
         pandecode_map_read_write();
 }
+#endif
+
+#if PAN_ARCH >= 10
+static void
+pandecode_cs_dump_state(uint32_t *state)
+{
+        uint64_t *st_64 = (uint64_t *)state;
+        /* Only registers below 0x40 seem to be actually be used by jobs */
+        for (unsigned i = 0; i < 0x40 / 4; ++i) {
+                uint64_t v1 = st_64[i * 2];
+                uint64_t v2 = st_64[i * 2 + 1];
+
+                if (!v1 && !v2)
+                        continue;
+
+                pandecode_log("0x%2x: 0x%16"PRIx64" 0x%16"PRIx64"\n",
+                              i * 4, v1, v2);
+        }
+}
+
+/* Assumes eight scoreboards */
+static void
+pandecode_scoreboard_mask(unsigned mask)
+{
+        if (mask == 0xff) {
+                pandecode_log_cont("all");
+                return;
+        } else if (!mask) {
+                pandecode_log_cont("none");
+                return;
+        }
+
+        const char *comma = "";
+        for (unsigned i = 0; i < 8; ++i) {
+                if (mask & (1 << i)) {
+                        pandecode_log_cont("%s%i", comma, i);
+                        comma = ",";
+                }
+        }
+}
+
+static void
+pandecode_regmask(unsigned base, unsigned mask)
+{
+        switch (mask) {
+        case 0:
+                pandecode_log_cont("(invalid: %02x mask 0)", base);
+                return;
+        case 1:
+                pandecode_log_cont("w%02x", base);
+                return;
+        case 3:
+                pandecode_log_cont("x%02x", base);
+                return;
+        default:
+                break;
+        }
+
+        unsigned first = ffs(mask) - 1;
+        if (first)
+                pandecode_log_cont("{(+%i) ", first);
+        else
+                pandecode_log_cont("{");
+
+        unsigned edges = mask ^ (mask << 1);
+
+        const char *comma = "";
+
+        bool outside = true;
+        unsigned start;
+        u_foreach_bit(i, edges) {
+                if (outside)
+                        start = i;
+                else if (i == start + 1)
+                        pandecode_log_cont("%sw%02x", comma,
+                                           base + start);
+                else if (i == start + 2)
+                        pandecode_log_cont("%sx%02x", comma,
+                                           base + start);
+                else
+                        pandecode_log_cont("%sw%02x-w%02x", comma,
+                                           base + start,
+                                           base + i - 1);
+                outside = !outside;
+
+                if (outside)
+                        comma = ", ";
+        }
+
+        pandecode_log_cont("}");
+}
+
+static void
+pandecode_cs_buffer(uint64_t *commands, unsigned size,
+                    uint32_t *buffer, uint32_t *buffer_unk,
+                    unsigned gpu_id, mali_ptr va);
+
+// Hack hack hackity hack: gpu_id == 1 means "don't decode" (only disassemble)
+static void
+pandecode_cs_command(uint64_t command, mali_ptr va,
+                     uint32_t *buffer, uint32_t *buffer_unk,
+                     unsigned gpu_id)
+{
+        uint8_t op = command >> 56;
+        uint8_t addr = (command >> 48) & 0xff;
+        uint64_t value = command & 0xffffffffffffULL;
+
+        uint32_t h = value >> 32;
+        uint32_t l = value;
+
+        uint8_t arg1 = h & 0xff;
+        uint8_t arg2 = h >> 8;
+
+        if (command)
+                pandecode_log("%"PRIx64" %016"PRIx64" ", va, command);
+
+        switch (op) {
+        case 0:
+                if (addr || value)
+                        pandecode_log("nop %02x, #0x%"PRIx64"\n", addr, value);
+                break;
+        case 1:
+                buffer_unk[addr] = buffer[addr] = l;
+                buffer_unk[addr + 1] = buffer[addr + 1] = h;
+                pandecode_log("mov x%02x, #0x%"PRIx64"\n", addr, value);
+                break;
+        case 2:
+                buffer_unk[addr] = buffer[addr] = l;
+                pandecode_log("mov w%02x, #0x%"PRIx64"\n", addr, value);
+                break;
+        case 3:
+                if (l & 0xff00ffff || h || addr) {
+                        pandecode_log("wait (unk %02x), (unk %04x), "
+                                      "%i, (unk %04x)\n", addr, h, l >> 16, l);
+                } else {
+                        pandecode_log("wait ");
+                        pandecode_scoreboard_mask(l >> 16);
+                        pandecode_log_cont("\n");
+                }
+                break;
+        case 4: {
+                uint32_t masked = l & 0xffff0000;
+                unsigned task_increment = l & 0x3fff;
+                unsigned task_axis = (l >> 14) & 3;
+                if (h != 0xff00 || addr || masked)
+                        pandecode_log("compute (unk %02x), (unk %04x), "
+                                      "(unk %x), inc %i, axis %i\n\n", addr, h, masked, task_increment, task_axis);
+                else
+                        pandecode_log("compute inc %i, axis %i\n\n", task_increment, task_axis);
+
+                if (gpu_id != 1) {
+                        pandecode_indent++;
+
+                        pandecode_compute_job(0, buffer, buffer_unk, gpu_id);
+
+                        /* The gallium driver emits this even for compute jobs, clear
+                         * it from unknown state */
+                        pan_unpack_cs(buffer, buffer_unk, SCISSOR, unused_scissor);
+                        pandecode_cs_dump_state(buffer_unk);
+
+                        pandecode_log("\n");
+                        pandecode_indent--;
+                }
+
+                break;
+        }
+        case 6: {
+                /* The meaning of the first argument (in h) is unknown, but it
+                 * appears that the second bit must be set. */
+                uint32_t masked = l & 0xfffff8f0;
+                uint8_t mode = l & 0xf;
+                uint8_t index = (l >> 8) & 7;
+                if (addr || masked)
+                        pandecode_log("idvs (unk %02x), 0x%04x, (unk %x), "
+                                      "mode %i index %i\n\n",
+                                      addr, h, masked, mode, index);
+                else
+                        pandecode_log("idvs 0x%04x, mode %i index %i\n\n",
+                                      h, mode, index);
+
+                if (gpu_id != 1) {
+                        pandecode_indent++;
+
+                        pandecode_malloc_vertex_job(0, buffer, buffer_unk, gpu_id);
+                        pandecode_cs_dump_state(buffer_unk);
+
+                        pandecode_log("\n");
+                        pandecode_indent--;
+                }
+
+                break;
+        }
+        case 7: {
+                uint64_t masked = value & ~0x000100000071;
+                bool tem = value & 1;
+                bool unk = (value >> 32) & 1;
+
+                const char *order = (const char *[]){
+                        "z_order",
+                        "horizontal",
+                        "vertical",
+                        "invalid_3",
+                        "invalid_4",
+                        "reverse_horizontal",
+                        "reverse_vertical",
+                        "invalid_7",
+                }[(value >> 4) & 7];
+
+                if (addr || masked) {
+                        pandecode_log("fragment (unk %02x), (unk %"PRIx64")\n\n",
+                                      addr, value);
+                } else if (value) {
+                        pandecode_log("fragment tem %i, render %s, unk %i\n\n",
+                                      tem, order, unk);
+                } else {
+                        pandecode_log("fragment\n\n");
+                }
+
+                if (gpu_id != 1) {
+                        pandecode_indent++;
+
+                        pandecode_fragment_job(0, buffer, buffer_unk, gpu_id);
+                        pandecode_cs_dump_state(buffer_unk);
+
+                        pandecode_log("\n");
+                        pandecode_indent--;
+                }
+
+                break;
+        }
+
+        case 9: {
+                if (addr || l || h > 1)
+                        pandecode_log("flush_tiler (unk %02x), (unk %"PRIx64")\n",
+                                      addr, value);
+                else if (h)
+                        pandecode_log("flush_tiler unk\n");
+                else
+                        pandecode_log("flush_tiler\n");
+                break;
+        }
+
+        case 16: case 17: {
+                char wid = (op == 16) ? 'w' : 'x';
+
+                if (op == 16) {
+                        buffer_unk[addr] = buffer[addr] = buffer[arg2] + l;
+                } else {
+                        uint64_t r = buffer[arg2] + ((uint64_t)buffer[arg2 + 1] << 32) + l;
+                        buffer_unk[addr] = buffer[addr] = r;
+                        buffer_unk[addr + 1] = buffer[addr + 1] = r >> 32;
+                }
+
+                if (arg1)
+                        pandecode_log("add %c%02x, (unk %x), %c%02x, #0x%x\n",
+                                      wid, addr, arg1, wid, arg2, l);
+                else if ((int32_t) l < 0)
+                        pandecode_log("add %c%02x, %c%02x, %i\n",
+                                      wid, addr, wid, arg2, (int32_t) l);
+                else if (l)
+                        pandecode_log("add %c%02x, %c%02x, #0x%x\n",
+                                      wid, addr, wid, arg2, l);
+                else
+                        pandecode_log("mov %c%02x, %c%02x\n",
+                                      wid, addr, wid, arg2);
+
+                break;
+        }
+
+        case 20: case 21: {
+                const char *name = (op == 20) ? "ldr" : "str";
+
+                /* The immediate offset must be 4-aligned (though if the
+                 * address itself is unaligned, the bits will silently be
+                 * masked off).
+                 *
+                 * Up to 16 32-bit registers can be read or written in a
+                 * single instruction, behaviour is similar to LDM or STM
+                 * except that a base register is specified.
+                 *
+                 * These instructions are high latency. Use WAIT 0 to wait for
+                 * the result of an LDR, or for a STR to finish.
+                 *
+                 * For LDR, it is an error for the address register to be
+                 * included in the destination register set.
+                 */
+
+                if (arg1) {
+                        pandecode_log("%s (unk %02x), x%02x, (mask %x), [x%02x, %i]\n",
+                                      name, arg1, addr, l >> 16, arg2, (int16_t) l);
+                } else {
+                        pandecode_log("%s ", name);
+                        pandecode_regmask(addr, l >> 16);
+                        pandecode_log_cont(", [x%02x, %i]\n", arg2, (int16_t) l);
+                }
+                break;
+        }
+
+        case 22: {
+                /* The signed 32-bit source register is compared against zero
+                 * for these comparisons. For example, .GT means that the
+                 * branch is taken if the signed register value is greater
+                 * than zero. */
+                const char *comparisons[] = {
+                        ".le", ".gt",
+                        ".eq", ".ne",
+                        ".lt", ".ge",
+                        "" /* always */, ".(invalid: never)",
+                };
+
+                const char *m = comparisons[(l >> 28) & 7];
+
+                int16_t offset = l;
+
+                bool forward = (offset >= 0);
+                if (!forward)
+                        offset = -1 - offset;
+
+                if (addr || arg1 || l & 0x8fff0000) {
+                        pandecode_log("b%s (unk %02x), w%02x, (unk %02x), "
+                                      "(unk 0x%x), %s %i\n",
+                                      m, addr, arg2, arg1, l & 0x8fff0000,
+                                      forward ? "skip" : "back",
+                                      offset);
+                } else {
+                        pandecode_log("b%s w%02x, %s %i\n",
+                                      m, arg2,
+                                      forward ? "skip" : "back",
+                                      offset);
+                }
+
+                break;
+        }
+
+        case 23: {
+                if (value >> 3 || addr)
+                        pandecode_log("slot (unk %02x), (unk %"PRIx64"), "
+                                      "%i\n", addr, value >> 3, l & 7);
+                else
+                        pandecode_log("slot %i\n", l);
+                break;
+        }
+
+        case 32: case 33: {
+                /* A tail call is similar to a normal call, but reuses the
+                 * current stack entry so that execution returns directly to
+                 * the parent, rather than pushing a new entry and returning
+                 * to the instruction after the call. Using tail calls avoids
+                 * the possibility of stack overflow.
+                 */
+                const char *name = (op == 32) ? "call" : "tailcall";
+
+                unsigned length = buffer[arg1];
+                uint64_t target = (((uint64_t)buffer[arg2 + 1]) << 32) | buffer[arg2];
+
+                assert(!(length & 7));
+                unsigned instrs = length / 8;
+
+                if (addr || l)
+                        pandecode_log("%s (unk %02x), w%02x (%i instructions), x%02x (0x%"PRIx64"), (unk %x)\n",
+                                      name, addr, arg1, instrs, arg2, target, l);
+                else
+                        pandecode_log("%s w%02x (%i instructions), x%02x (0x%"PRIx64")\n",
+                                      name, arg1, instrs, arg2, target);
+
+                if (!target || !length)
+                        break;
+
+                uint64_t *t = pandecode_fetch_gpu_mem(target, length);
+                pandecode_indent++;
+                pandecode_cs_buffer(t, length, buffer, buffer_unk, gpu_id,
+                                    target);
+                pandecode_indent--;
+                break;
+        }
+
+        case 34: {
+                /* idvs implies tiler */
+                if (l & ~0xf)
+                        pandecode_log("resources 0x%x\n", l);
+                else
+                        pandecode_log("resources%s%s%s%s\n",
+                                      (l & 1) ? " compute" : "",
+                                      (l & 2) ? " fragment" : "",
+                                      (l & 4) ? " tiler" : "",
+                                      (l & 8) ? " idvs" : "");
+                break;
+        }
+
+        case 37: case 38: case 51: case 52: {
+                /*
+                 * 0b 00100101 / 00100110 -- opcode
+                 *    ????0??? -- unk. usually 1, faults if "0" bit set
+                 *    aaaaaaaa -- address register
+                 *    vvvvvvvv -- 32-bit value register
+                 *    00000000 -- seems to act as NOP if nonzero
+                 *    mmmmmmmm -- some sort of mask, unknown purpose
+                 *    ???????? -- seems to have no effect
+                 *    ?????s0u -- 's' disables signal to CPU,
+                 *                'u' has unknown purpose (disable GPU signal?)
+                 *
+                 * The difference between the two opcodes is unknown.
+                 *
+                 * That the 'mmmmmmmm' byte is somehow a scoreboard mask is
+                 * a possibility.
+                 */
+
+                const char *name = (op & 1) ? "evadd" : "evstr";
+                const char *type = (op > 50) ? "x" : "w";
+
+                if (addr != 1 || l & 0xff00fffa) {
+                        pandecode_log("%s (unk %02x), %s%02x, [x%02x], "
+                                      "unk 0x%x, flags 0x%x\n",
+                                      name, addr, type, arg1, arg2,
+                                      l >> 16, (uint16_t) l);
+                } else {
+                        pandecode_log("%s %s%02x, [x%02x], unk 0x%x%s%s\n",
+                                      name, type, arg1, arg2, l >> 16,
+                                      l & 0x4 ? "" : ", irq",
+                                      l & 0x1 ? ", unk0" : "");
+                }
+
+                break;
+        }
+
+        case 39: case 53: {
+                const char *m = (const char *[]){
+                        ".ls",
+                        ".hi",
+                }[(l >> 28) & 1];
+                const char *e = (const char *[]){
+                        ".inherit",
+                        ".no_error",
+                }[l & 1];
+                const char *type = (op > 50) ? "x" : "w";
+
+                /* Wait until the value in the destination register is changed
+                 * to pass the comparison. For example, with .LS the value
+                 * in memory must be less than or same as the reference to
+                 * continue execution. */
+                if (addr || l & ~((1 << 28) | (1 << 0)))
+                        pandecode_log("evwait%s%s (unk %02x), %s%02x, "
+                                      "[x%02x, unk %x]\n",
+                                      m, e, addr, type, arg1, arg2, l);
+                else
+                        pandecode_log("evwait%s%s %s%02x, [x%02x]\n",
+                                      m, e, type, arg1, arg2);
+                break;
+        }
+
+        case 40: {
+                if (addr || l >> 16 || arg1 > 1) {
+                        pandecode_log("str type %02x, (unk %02x), "
+                                      "(unk %x), [x%02x, %i]\n",
+                                      addr, arg1,
+                                      l >> 16, arg2, (int16_t) l);
+                } else {
+                        const char *type = (const char *[]) {
+                                "timestamp",
+                                "cycles",
+                        }[arg1];
+
+                        pandecode_log("str %s, [x%02x, %i]\n",
+                                      type, arg2, (int16_t) l);
+                }
+                break;
+        }
+
+        case 48: {
+                if (addr || arg1 || l)
+                        pandecode_log("heapctx (unk %02x), "
+                                      "x%02x, (unk %02x), (unk %x)\n",
+                                      addr, arg2, arg1, l);
+                else
+                        pandecode_log("heapctx x%02x\n", arg2);
+                break;
+        }
+
+        case 49: {
+                const char *m = (const char *[]){
+                        "vt_start",
+                        "vt_end",
+                        "unk",
+                        "frag_end",
+                }[arg1 & 3];
+
+                if (addr || arg2 || arg1 > 3 || l)
+                        pandecode_log("heapinc (unk %02x), "
+                                      "(unk %02x), %02x, (unk %x)\n",
+                                      addr, arg2, arg1, l);
+                else
+                        pandecode_log("heapinc %s\n", m);
+                break;
+        }
+
+        default:
+                /*
+                 * UNK 00 30, #0x480000000000 -- takes an eight-byte aligned
+                 * memory address.
+                 */
+
+                pandecode_log("UNK %02x %02x, #0x%"PRIx64"\n", addr, op, value);
+                break;
+        }
+}
+
+// TODO: reorder args
+static void
+pandecode_cs_buffer(uint64_t *commands, unsigned size,
+                    uint32_t *buffer, uint32_t *buffer_unk,
+                    unsigned gpu_id, mali_ptr va)
+{
+        uint64_t *end = (uint64_t *)((uint8_t *) commands + size);
+
+        for (uint64_t c = *commands; commands < end; c = *(++commands)) {
+                pandecode_cs_command(c, va, buffer, buffer_unk, gpu_id);
+                va += 8;
+        }
+}
+
+// TODO: Does it make sense to pass in the length?
+void
+GENX(pandecode_cs)(mali_ptr cs_gpu_va, unsigned size, unsigned gpu_id)
+{
+        pandecode_dump_file_open();
+
+        // TODO: Pass down the buffer during recursion
+        uint32_t buffer[256] = {0};
+        uint32_t buffer_unk[256] = {0};
+
+        uint64_t *commands = pandecode_fetch_gpu_mem(cs_gpu_va, 1);
+
+        pandecode_log("\n");
+
+        pandecode_cs_buffer(commands, size, buffer, buffer_unk, gpu_id,
+                            cs_gpu_va);
+
+        fflush(pandecode_dump_stream);
+        pandecode_map_read_write();
+}
+#endif
