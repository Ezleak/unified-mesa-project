diff a/src/panfrost/lib/pan_device.h b/src/panfrost/lib/pan_device.h	(rejected hunks)
@@ -35,11 +35,12 @@
 #include "util/u_dynarray.h"
 #include "util/bitset.h"
 #include "util/list.h"
-#include "util/sparse_array.h"
+#include "util/stable_array.h"
 
 #include "panfrost/util/pan_ir.h"
 #include "pan_pool.h"
 #include "pan_util.h"
+#include "pan_base.h"
 
 #include <genxml/gen_macros.h>
 
@@ -182,6 +183,7 @@ struct panfrost_device {
         void *memctx;
 
         int fd;
+        bool kbase;
 
         /* Properties of the GPU in use */
         unsigned arch;
@@ -204,6 +206,9 @@ struct panfrost_device {
         const struct panfrost_model *model;
         bool has_afbc;
 
+        /* Does the kernel support dma-buf fence import/export? */
+        bool has_dmabuf_fence;
+
         /* Table of formats, indexed by a PIPE format */
         const struct panfrost_format *formats;
 
@@ -217,8 +222,11 @@ struct panfrost_device {
 
         struct renderonly *ro;
 
+        /* Hold this while updating usage field of BOs */
+        pthread_mutex_t bo_usage_lock;
+
         pthread_mutex_t bo_map_lock;
-        struct util_sparse_array bo_map;
+        struct stable_array bo_map;
 
         struct {
                 pthread_mutex_t lock;
@@ -263,6 +271,10 @@ struct panfrost_device {
          * unconditionally on Bifrost, and useful for sharing with Midgard */
 
         struct panfrost_bo *sample_positions;
+
+        struct kbase_ mali;
+
+        FILE *bo_log;
 };
 
 void
@@ -271,6 +283,9 @@ panfrost_open_device(void *memctx, int fd, struct panfrost_device *dev);
 void
 panfrost_close_device(struct panfrost_device *dev);
 
+bool
+panfrost_check_dmabuf_fence(struct panfrost_device *dev);
+
 bool
 panfrost_supports_compressed_format(struct panfrost_device *dev, unsigned fmt);
 
@@ -287,12 +302,18 @@ panfrost_query_sample_position(
                 float *out);
 
 unsigned
-panfrost_query_l2_slices(const struct panfrost_device *dev);
+panfrost_query_l2_slices(struct panfrost_device *dev);
 
 static inline struct panfrost_bo *
 pan_lookup_bo(struct panfrost_device *dev, uint32_t gem_handle)
 {
-        return (struct panfrost_bo *)util_sparse_array_get(&dev->bo_map, gem_handle);
+        return stable_array_get(&dev->bo_map, struct panfrost_bo, gem_handle);
+}
+
+static inline struct panfrost_bo *
+pan_lookup_bo_existing(struct panfrost_device *dev, uint32_t gem_handle)
+{
+        return stable_array_get_existing(&dev->bo_map, struct panfrost_bo, gem_handle);
 }
 
 static inline bool
