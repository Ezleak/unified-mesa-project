diff a/src/gallium/drivers/panfrost/pan_context.c b/src/gallium/drivers/panfrost/pan_context.c	(rejected hunks)
@@ -34,7 +34,6 @@
 
 #include "util/macros.h"
 #include "util/format/u_format.h"
-#include "util/libsync.h"
 #include "util/u_inlines.h"
 #include "util/u_upload_mgr.h"
 #include "util/u_memory.h"
@@ -571,6 +570,19 @@ panfrost_destroy(struct pipe_context *pipe)
         struct panfrost_context *panfrost = pan_context(pipe);
         struct panfrost_device *dev = pan_device(pipe->screen);
 
+        if (dev->kbase && dev->mali.context_create) {
+                dev->mali.cs_term(&dev->mali, &panfrost->kbase_cs_vertex.base);
+                dev->mali.cs_term(&dev->mali, &panfrost->kbase_cs_fragment.base);
+
+                dev->mali.context_destroy(&dev->mali, panfrost->kbase_ctx);
+
+                panfrost_bo_unreference(panfrost->kbase_cs_vertex.bo);
+                panfrost_bo_unreference(panfrost->kbase_cs_fragment.bo);
+        }
+
+        if (panfrost->tiler_heap_desc)
+                panfrost_bo_unreference(panfrost->tiler_heap_desc);
+
         _mesa_hash_table_destroy(panfrost->writers, NULL);
 
         if (panfrost->blitter)
@@ -582,11 +594,15 @@ panfrost_destroy(struct pipe_context *pipe)
         panfrost_pool_cleanup(&panfrost->descs);
         panfrost_pool_cleanup(&panfrost->shaders);
 
-        drmSyncobjDestroy(dev->fd, panfrost->in_sync_obj);
-        if (panfrost->in_sync_fd != -1)
-                close(panfrost->in_sync_fd);
+        if (dev->kbase) {
+                dev->mali.syncobj_destroy(&dev->mali, panfrost->syncobj_kbase);
+        } else {
+                drmSyncobjDestroy(dev->fd, panfrost->in_sync_obj);
+                if (panfrost->in_sync_fd != -1)
+                        close(panfrost->in_sync_fd);
 
-        drmSyncobjDestroy(dev->fd, panfrost->syncobj);
+                drmSyncobjDestroy(dev->fd, panfrost->syncobj);
+        }
         ralloc_free(pipe);
 }
 
@@ -873,6 +889,58 @@ panfrost_create_fence_fd(struct pipe_context *pctx,
         *pfence = panfrost_fence_from_fd(pan_context(pctx), fd, type);
 }
 
+struct sync_merge_data {
+	char	name[32];
+	int32_t	fd2;
+	int32_t	fence;
+	uint32_t	flags;
+	uint32_t	pad;
+};
+
+#define SYNC_IOC_MAGIC		'>'
+#define SYNC_IOC_MERGE		_IOWR(SYNC_IOC_MAGIC, 3, struct sync_merge_data)
+
+static inline int sync_merge(const char *name, int fd1, int fd2)
+{
+	struct sync_merge_data data = {{0}};
+	int ret;
+
+	data.fd2 = fd2;
+	strncpy(data.name, name, sizeof(data.name));
+
+	do {
+		ret = ioctl(fd1, SYNC_IOC_MERGE, &data);
+	} while (ret == -1 && (errno == EINTR || errno == EAGAIN));
+
+	if (ret < 0)
+		return ret;
+
+	return data.fence;
+}
+
+static inline int sync_accumulate(const char *name, int *fd1, int fd2)
+{
+	int ret;
+
+	assert(fd2 >= 0);
+
+	if (*fd1 < 0) {
+		*fd1 = dup(fd2);
+		return 0;
+	}
+
+	ret = sync_merge(name, *fd1, fd2);
+	if (ret < 0) {
+		/* leave *fd1 as it is */
+		return ret;
+	}
+
+	close(*fd1);
+	*fd1 = ret;
+
+	return 0;
+}
+
 static void
 panfrost_fence_server_sync(struct pipe_context *pctx,
                            struct pipe_fence_handle *f)
@@ -888,6 +956,28 @@ panfrost_fence_server_sync(struct pipe_context *pctx,
         close(fd);
 }
 
+static struct panfrost_cs
+panfrost_cs_create(struct panfrost_context *ctx, unsigned size, unsigned mask)
+{
+        struct panfrost_screen *screen = pan_screen(ctx->base.screen);
+        struct panfrost_device *dev = pan_device(ctx->base.screen);
+        struct kbase_context *kctx = ctx->kbase_ctx;
+
+        struct panfrost_cs c = {0};
+
+        c.bo = panfrost_bo_create(dev, size, 0, "Command stream");
+
+        c.base = dev->mali.cs_bind(&dev->mali, kctx, c.bo->ptr.gpu, size);
+
+        c.event_ptr = dev->mali.event_mem.gpu + c.base.event_mem_offset * PAN_EVENT_SIZE;
+        c.kcpu_event_ptr = dev->mali.kcpu_event_mem.gpu + c.base.event_mem_offset * PAN_EVENT_SIZE;
+
+        c.hw_resources = mask;
+        screen->vtbl.init_cs(ctx, &c);
+
+        return c;
+}
+
 struct pipe_context *
 panfrost_create_context(struct pipe_screen *screen, void *priv, unsigned flags)
 {
@@ -981,6 +1071,14 @@ panfrost_create_context(struct pipe_screen *screen, void *priv, unsigned flags)
 
         assert(ctx->blitter);
 
+        if (dev->kbase && dev->mali.context_create)
+                ctx->kbase_ctx = dev->mali.context_create(&dev->mali);
+
+        if (dev->arch >= 10) {
+                ctx->kbase_cs_vertex = panfrost_cs_create(ctx, 65536, 13);
+                ctx->kbase_cs_fragment = panfrost_cs_create(ctx, 65536, 2);
+        }
+
         /* Prepare for render! */
 
         /* By default mask everything on */
@@ -992,13 +1090,18 @@ panfrost_create_context(struct pipe_screen *screen, void *priv, unsigned flags)
         /* Create a syncobj in a signaled state. Will be updated to point to the
          * last queued job out_sync every time we submit a new job.
          */
-        ret = drmSyncobjCreate(dev->fd, DRM_SYNCOBJ_CREATE_SIGNALED, &ctx->syncobj);
-        assert(!ret && ctx->syncobj);
-
-        /* Sync object/FD used for NATIVE_FENCE_FD. */
-        ctx->in_sync_fd = -1;
-        ret = drmSyncobjCreate(dev->fd, 0, &ctx->in_sync_obj);
-        assert(!ret);
+        if (dev->kbase) {
+                ctx->syncobj_kbase = dev->mali.syncobj_create(&dev->mali);
+                ctx->in_sync_fd = -1;
+        } else {
+                ret = drmSyncobjCreate(dev->fd, DRM_SYNCOBJ_CREATE_SIGNALED, &ctx->syncobj);
+                assert(!ret && ctx->syncobj);
+
+                /* Sync object/FD used for NATIVE_FENCE_FD. */
+                ctx->in_sync_fd = -1;
+                ret = drmSyncobjCreate(dev->fd, 0, &ctx->in_sync_obj);
+                assert(!ret);
+        }
 
         return gallium;
 }
