diff a/src/gallium/drivers/panfrost/pan_fence.c b/src/gallium/drivers/panfrost/pan_fence.c	(rejected hunks)
@@ -42,7 +42,10 @@ panfrost_fence_reference(struct pipe_screen *pscreen,
         struct pipe_fence_handle *old = *ptr;
 
         if (pipe_reference(&old->reference, &fence->reference)) {
-                drmSyncobjDestroy(dev->fd, old->syncobj);
+                if (dev->kbase)
+                        dev->mali.syncobj_destroy(&dev->mali, old->kbase);
+                else
+                        drmSyncobjDestroy(dev->fd, old->syncobj);
                 free(old);
         }
 
@@ -65,6 +68,13 @@ panfrost_fence_finish(struct pipe_screen *pscreen,
         if (abs_timeout == OS_TIMEOUT_INFINITE)
                 abs_timeout = INT64_MAX;
 
+        if (dev->kbase) {
+                /* TODO: Use the timeout */
+                bool ret = dev->mali.syncobj_wait(&dev->mali, fence->kbase);
+                fence->signaled = ret;
+                return ret;
+        }
+
         ret = drmSyncobjWait(dev->fd, &fence->syncobj,
                              1,
                              abs_timeout, DRM_SYNCOBJ_WAIT_FLAGS_WAIT_ALL,
@@ -81,6 +91,10 @@ panfrost_fence_get_fd(struct pipe_screen *screen,
         struct panfrost_device *dev = pan_device(screen);
         int fd = -1;
 
+        /* TODO: Export a sync file using KCPU */
+        if (dev->kbase)
+                return fd;
+
         drmSyncobjExportSyncFile(dev->fd, f->syncobj, &fd);
         return fd;
 }
@@ -92,6 +106,10 @@ panfrost_fence_from_fd(struct panfrost_context *ctx, int fd,
         struct panfrost_device *dev = pan_device(ctx->base.screen);
         int ret;
 
+        /* TODO: Implement this for kbase */
+        if (dev->kbase)
+                return NULL;
+
         struct pipe_fence_handle *f = calloc(1, sizeof(*f));
         if (!f)
                 return NULL;
@@ -134,6 +152,16 @@ panfrost_fence_create(struct panfrost_context *ctx)
         struct panfrost_device *dev = pan_device(ctx->base.screen);
         int fd = -1, ret;
 
+        if (dev->kbase) {
+                struct pipe_fence_handle *f = calloc(1, sizeof(*f));
+                if (!f)
+                        return NULL;
+
+                f->kbase = dev->mali.syncobj_dup(&dev->mali, ctx->syncobj_kbase);
+                pipe_reference_init(&f->reference, 1);
+                return f;
+        }
+
         /* Snapshot the last rendering out fence. We'd rather have another
          * syncobj instead of a sync file, but this is all we get.
          * (HandleToFD/FDToHandle just gives you another syncobj ID for the
