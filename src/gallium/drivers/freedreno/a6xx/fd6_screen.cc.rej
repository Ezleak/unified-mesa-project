diff a/src/gallium/drivers/freedreno/a6xx/fd6_screen.cc b/src/gallium/drivers/freedreno/a6xx/fd6_screen.cc	(rejected hunks)
@@ -157,26 +157,35 @@ fd6_screen_init(struct pipe_screen *pscreen)
 
    screen->max_rts = A6XX_MAX_RENDER_TARGETS;
 
-   screen->ccu_offset_bypass = screen->info->num_ccu * A6XX_CCU_DEPTH_SIZE;
+   printf("FD6: ccu\n");
+   screen->ccu_offset_bypass = 1 * A6XX_CCU_DEPTH_SIZE;
    screen->ccu_offset_gmem = (screen->gmemsize_bytes -
-         screen->info->num_ccu * A6XX_CCU_GMEM_COLOR_SIZE);
+         1 * A6XX_CCU_GMEM_COLOR_SIZE);
 
    /* Currently only FB_READ forces GMEM path, mostly because we'd have to
     * deal with cmdstream patching otherwise..
     */
+   printf("FD6: gmem mask\n");
    screen->gmem_reason_mask = (enum fd_gmem_reason)(
          FD_GMEM_CLEARS_DEPTH_STENCIL |
          FD_GMEM_DEPTH_ENABLED | FD_GMEM_STENCIL_ENABLED |
          FD_GMEM_BLEND_ENABLED | FD_GMEM_LOGICOP_ENABLED);
-
+   printf("FD6: create context\n");
    pscreen->context_create = fd6_context_create;
    pscreen->is_format_supported = fd6_screen_is_format_supported;
+   printf("FD6: tile mode\n");
 
    screen->tile_mode = fd6_tile_mode;
+   printf("FD6: screen init 1\n");
 
    fd6_resource_screen_init(pscreen);
+   printf("FD6: screen init 2\n");
+
    fd6_emit_init_screen(pscreen);
+   printf("FD6: screen init 3\n");
+
    ir3_screen_init(pscreen);
 
+   printf("FD6: screen init 4\n");
    screen->primtypes = primtypes;
 }
